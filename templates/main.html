<html>
    <head>

        <title>Radio SkyGUIde</title>
        <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
        <style>
            body { margin: 0; text-align: center; background-color: #000000}
            canvas { display: block; }
            gui {position: fixed; left:50%; top:0px; transform: translate(-50%, -0%);}
            .sidtime {position: fixed; left:5%; top:15%; font-family:Verdana; text-align: center;}
            .leftdetails {position: fixed; left:3%; top:5%; font-family:Verdana; text-align: center; transform: translate(0%,0%); overflow-y: scroll; height: 95%; width: 20%; }
            .rightdetails {position: fixed; left:80%; top:5%; font-family:Verdana; text-align: center; transform: translate(-5%,0%); overflow-y: scroll; height: 95%; width: 20%;}
            .button {
              background-color: var(--bcolor);
              border: none;
              color: white;
              padding: 15px 24px;
              text-align: center;
              display: inline-block;
              font-size: var(--fsize);
              margin: 4px 2px;
              cursor: pointer;
            }
			/*Checkboxes styles*/
			input[type="checkbox"] { display: none; }

			input[type="checkbox"] + label {
				display: block;
				position: relative;
				padding-left: 35px;
				margin-bottom: 20px;
				color: #ddd;
				cursor: pointer;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
			}

			input[type="checkbox"] + label:last-child { margin-bottom: 0; }

			input[type="checkbox"] + label:before {
				content: '';
				display: block;
				width: 20px;
				height: 20px;
				border: 1px solid #6cc0e5;
				position: absolute;
				left: 0;
				top: 0;
				opacity: .6;
				-webkit-transition: all .12s, border-color .08s;
				transition: all .12s, border-color .08s;
			}

			input[type="checkbox"]:checked + label:before {
				width: 10px;
				top: -5px;
				left: 5px;
				border-radius: 0;
				opacity: 1;
				border-top-color: transparent;
				border-left-color: transparent;
				-webkit-transform: rotate(45deg);
				transform: rotate(45deg);
			}
			/* width */
			::-webkit-scrollbar {
				width: 10px;
			}

			/* Track */
			::-webkit-scrollbar-track {
				background: #222;
			}

			/* Handle */
			::-webkit-scrollbar-thumb {
				background: #456789;
			}

			/* Handle on hover */
			::-webkit-scrollbar-thumb:hover {
				background: #345678;
			}



			.slidecontainer {
				width: 100%; /* Width of the outside container */
			}

			/* The slider itself */
			.slider {
				-webkit-appearance: none;  /* Override default CSS styles */
				appearance: none;
				width: 80%; /* Full-width */
				height: 25px; /* Specified height */
				background: #123456; /* Grey background */
				outline: none; /* Remove outline */
				opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
				-webkit-transition: .2s; /* 0.2 seconds transition on hover */
				transition: opacity .2s;
			}

			/* Mouse-over effects */
			.slider:hover {
				opacity: 1; /* Fully shown on mouse-over */
			}

			/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
			.slider::-webkit-slider-thumb {
				-webkit-appearance: none; /* Override default look */
				appearance: none;
				width: 25px; /* Set a specific slider handle width */
				height: 25px; /* Slider handle height */
				background: #9400d3; /* Green background */
				cursor: pointer; /* Cursor on hover */
			}


			select {
				width: 50%;
				height: 40px;
				font-size: 15px;
				cursor: pointer;
				border-radius: 0;
				background-color: #5511a0;
				border: none;
				border-bottom: 2px solid #220088;
				color: white;
				padding: 10px;
				appearance: none;
				-webkit-appearance: none;
				-moz-appearance: none;
				padding: 10px;
			}

			select:focus{
				outline: none;
			}

			swal.fire({
				icon: 'warning',
				title: 'Quick Note',
				text: 'Interactive mode is in development, and might be a little buggy. It is also not compatible with the antennae view - please switch back to non-interactive to use those. Rendering satellites with interactive mode might also be a little laggy.',
				footer: 'Radio SkyGUIde'
			})
        </style>
        <script language="javascript" type="text/javascript" src="/static/astro.js"></script>
        <script language="javascript" type="text/javascript" src="/static/astro.ephem.js"></script>
        <script language="javascript" type="text/javascript" src="https://threejs.org/build/three.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>
        <script language="javascript" type="text/javascript" src="/static/examples/js/controls/TrackballControls.js"></script>
        <script language="javascript" type="text/javascript" src="/static/examples/js/renderers/Projector.js"></script>
        <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    </head>
    <body>
    	<div id="testdiv" style="color: #FFF; z-index: 5; position: absolute;">
    	</div>

        <div id="leftdetails" class="leftdetails">
            <input type="button" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Approximate LST at the {{ abbr_here }}">

            <br>

            <span id="sidtime"></span>

            <br><br><br>

            <span id="antennae">

            <input type="button" class="button" style="--bcolor: #3f1166; --fsize: 15px;" value="Available Antennae">

            <br>

            <select id="antenna_select" onchange="javascript:changeAntenna();">
              <option value="none">None</option>
            </select>

            </span>

            <br><br>

            <input id="objectsearchbar" type="text" class="button" style="padding: 10px 0px;border-color: black; font-size: 17px; outline: none; background-color: #bbb; align-self: left !important; text-align: left; padding-left: 5%; padding-right: 5%; color: #000" placeholder="&#x1F50E;Object Search" onkeypress="javascript:dealWithSearchBar(event)">

            <br>

            <div id="objectmatchestitle" style='color: #67F; text-align: left !important; padding-left: 5%; padding-right: 5%; padding-top: 5%; padding-bottom: 5%;'>
            </div>

            <div id="objectsearch" style="color: #67F; text-align: left !important; padding-left: 5%; padding-right: 5%; padding-top: 2%; padding-bottom: 5%; height: 10%; overflow-y: scroll">
            </div>

            <br>

            <div>
                <br>

                <table style="text-align: center; display:inline;">

                <tr>

                <td>
                <input type="button" class="button" style="--bcolor: #749fd8; --fsize: 15px; font-family: courier" value="+5m" onclick="offsetRA(1.25);">
                </td>

                <td>
                <input type="button" class="button" style="--bcolor: #cb8080; --fsize: 15px; font-family: courier" value="-5m" onclick="offsetRA(-1.25);">
                </td>

                </tr>
                
                <tr>

                <td>
                <input type="button" class="button" style="--bcolor: #356fbb; --fsize: 15px; font-family: courier" value="+1h" onclick="offsetRA(15);">
                </td>

                <td>
                <input type="button" class="button" style="--bcolor: #b54a4a; --fsize: 15px; font-family: courier" value="-1h" onclick="offsetRA(-15);">
                </td>

            	</tr>

                </table>

                <br>
                <input type="text" class="button" id="delaybox" style="--bcolor: #553555; --fsize: 15px;" placeholder="Custom Time Offset" onkeypress="javascript:customRaOffset(event);">

                <br>

                <input type="text" class="button" id="cont_del_box" style="--bcolor: #553555; --fsize: 15px;" placeholder="Animate (Min/Sec)" onkeypress="javascript:delayAnimate(event)">

                <br>

                <input type="button" class="button" style="--bcolor: #553555; --fsize: 15px;" value="Reset and Re-center" onclick="offsetRA(0, true); controls.reset()">

                <br>

                <div id="totaloffset">
                    <input type="button" class="button" style="--bcolor: #444444; --fsize: 15px;" value="Total Time Offset (min): 0">
                </div>
            </div>
            <br>
        </div>

        <div id="crosshairtext" style="position:absolute; display:inline-block; top:45%; left:52%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>

        <div id="crosshair_fov_text" style="position:absolute; display:inline-block; top:30%; left:43%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>

        <div id="crosshair_direction_text" style="position:absolute; display:inline-block; top:2%; left:50%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>

        <div id='rightdetails' class='rightdetails'>
        	<!-- Currently Selected Object -->
            <div id="currentlyshowing" style="display: inline; color: #56789a">Currently Selected<br><br>
                <div id="currentobject">None</div>
            </div>

            <br><br>

            <!-- Catalog names and checkboxes -->
            <div style="text-align: left">
            <form>

                <input type="checkbox" name="drawatnf" value="true" id="drawatnf" onclick="dealWithCheckboxes();" checked>
                <label for="drawatnf" style="color: #FF0000; display:inline">ATNF Catalog</label><br><br>

                <input type="checkbox" name="drawfrb" value="true" id="drawfrb" onclick="dealWithCheckboxes();">
                <label for='drawfrb' style="color: #00FF00; display:inline">FRB Catalog</label><br><br>

                <input type="checkbox" name="drawrrat" value="true" id="drawrrat" onclick="dealWithCheckboxes();">
                <label for='drawrrat' style="color: #FFFF00; display:inline">RRATalog</label><br><br>

                <input type="checkbox" name="drawnvss" value="true" id="drawnvss" onclick="nvssDialogue();">
                <label id='fornvss' for='drawnvss' style="color: #9400d3; display:inline">NVSS Catalog (>0.2 Jy)</label><br><br>

                <input type="range" min="0.2" max="5" value="0" class="slider" id="nvss_slider" step="0.0001" onchange="dealWithNVSSSlider();"><br><br>

                <input type="checkbox" name="drawmessier" value="true" id="drawmessier" onclick="dealWithCheckboxes();">
                <label for='drawmessier' style="color: #00AAFF; display:inline">Messier Catalog</label><br><br>

                <input type="checkbox" name="drawsatellites" value="true" id="drawsatellites" onclick="dealWithCheckboxes();">
                <label for='drawsatellites' style="color: #FFFFFF; display:inline">Starlink Satellites</label><br><br>

                <input type="checkbox" name="drawflights" value="true" id="drawflights" onclick="dealWithFlightCheckbox();">
                <label for='drawflights' style="color: #AAA; display:inline">Commercial Flights

                    <br>
                    <div style="color: #AAA; font-size: 12px">
                        <br>
                        Credits to
                        <a href="http://www.opensky-network.org" style="color: #AAD" target="_blank">OpenSky API</a>
                    </div>

                </label><br>

                <input type="checkbox" name="drawimportant" value="true" id="drawimportant" onclick="dealWithCheckboxes();" checked>
                <label for='drawimportant' style="color: #00FFF8; display:inline">Important Objects</label><br><br>

                <a href="javascript:triggerLogInPanel()" style="color: #aaa;">
                    User-Defined Objects...
                </a>
            </form>
            
            <br>

            <!-- Checkboxes for grid types -->

            <form>
                <input type="checkbox" name="equatorialcheckbox" value="true" id="equatorialcheckbox" onclick="gridCheckboxes();">
                <label for="equatorialcheckbox" style="color: #999999; display:inline">Equatorial Grid</label>
                <br><br>
                <input type="checkbox" name="altazcheckbox" value="true" id="altazcheckbox" onclick="gridCheckboxes();" checked>
                <label for="altazcheckbox" style="color: #999999; display:inline">Alt-Az Grid</label>
            </form>

            </div>

            <br><br>

            <!-- Some hidden values that will get passed when going into interactive mode -->
            <form action='/main'>
                <input type="hidden" name="alt" value="90">
                <input type="hidden" name="az" value="0">
                <input type="hidden" name="fov" value="90">
                <input type="hidden" name="antenna" value="none">
                <input type="hidden" name="loc" value="{{ loc_here }}">
                <input type="hidden" name="longitude" value="{{ longitude_here }}">
                <input type="hidden" name="latitude" value="{{ declination_here }}">
                <input type="hidden" name="controls" id="controls" value="tobefilled">
                <input type="Submit" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Toggle Interactive Mode">
            </form>

            <br>

            <form action='/'>
                <input type="Submit" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Restart">
            </form>

            <!-- this is left-over from an older interface where alt, az, and fov were input textboxes. I left them here, and now they are used as "variables". It's a tad convoluted, but restructuring this isn't a top priority at the moment. -->
            <div id="modifyaltaz">
                <!--<input id="alt_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="Altitude (&#176)" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="alt_box" type="hidden">
                <br>

                <!--<input id="az_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="Azimuth: North = 0&#176" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="az_box" type="hidden">
                <br>

                <!--<input id="fov_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="FOV (&#176)" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="fov_box" type="hidden">
                <br>
            </div>
            <br>

        </div>

        <!-- Login panel html - the display property will be toggled on to trigger the panel  -->

        <div id="bgblur" style="position:absolute; left:0 top: 0; width: 100%; height: 100%; background-color: rgba(10, 10, 10, 0.6); z-index: 4; display: none; backdrop-filter: blur(10px)">
        </div>

        <div id="loginpanel" style="position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-image: url('static/sagstarcloud.JPG'); background-size: 200%; width: 30%; height: 62%; border: 0px solid #ddd; display: none; z-index: 5; border-radius: 100%">

            <!-- close window button -->
            <input type="button" class="button" value="X" style="--bcolor: rgba(0, 0, 0, 0); background-image: url('static/redgiant.png'); background-position: 50% 50%; --fsize: 18px; padding: 0 0; margin: 0 0; position: fixed; background-size: 100%; background-repeat: no-repeat; left: 50%; top: -20%; display: inline; width: 12%; height: 12%; outline: none; border-radius: 0%; transform: translate(-50%, 0); color: #000; text-align: center" onclick="javascript:hideLoginPanel();">

            <!-- galaxy -->
            <div style="position: fixed; left: 100%; top: 17%; background-image: url('static/galaxy.png'); width: 25%; height: 25%; background-size: 100%; transform: translate(0, -50%); background-position: 50% 50%; background-repeat: no-repeat;">
            </div>

            <!-- jupiter -->
            <div style="position: fixed; left: 18%; top: 96%; background-image: url('static/jupiter.png'); width: 25%; height: 25%; background-size: 100%; transform: translate(-50%, 0%); background-position: 50% 50%; background-repeat: no-repeat;">
            </div>            

            <!-- saturn -->
            <div style="position: fixed; left: -25%; top: 18%; background-image: url('static/saturn.png'); width: 30%; height: 30%; background-size: 100%; transform: translate(0, -50%); background-position: 50% 50%; background-repeat: no-repeat;">
            </div>

            <!-- moon -->
            <div style="position: fixed; left: 90%; top: 97%; background-image: url('static/moonimg.png'); width: 15%; height: 15%; background-size: 100%; transform: translate(0, -50%); background-position: 50% 50%; background-repeat: no-repeat;">
            </div>

            <div style="color: #88b; font-family: Helvetica; font-size: 20px; text-align: center; margin-left: 0%; margin-top: 11%">
                <br>
                Log In
                <br>
                <div>
                    <input onkeypress="javascript:sendLoginRequest(event)" name="username" id="login_user" type="text" class="button" style="--bcolor: rgba(0, 0, 0, 0); --fsize: 15px; padding: 10px 5px; border-top: none; border-right: none; border-left: none; border-bottom: solid #7878ab 2px; outline: none" placeholder="Username">
                    <br>
                    <input onkeypress="javascript:sendLoginRequest(event)" name="password" id="login_pass" type="password" class="button"style="--bcolor: rgba(0, 0, 0, 0); --fsize: 15px; padding: 10px 5px; border-top: none; border-right: none; border-left: none; border-bottom: solid #7878ab 2px; outline: none" placeholder="Password">
                    <br>
                    <div id="loginResult" style="font-size: 10px; color: #aa2222; z-index: 6">
                        <br>
                    </div>
                </div>

                <br>
                Create New Account
                <br>
                <div>
                    <input onkeypress="javascript:sendLoginRequest(event, true)" name="username" id="create_user" type="text" class="button" style="--bcolor: rgba(0, 0, 0, 0); --fsize: 15px; padding: 10px 5px; border-top: none; border-right: none; border-left: none; border-bottom: solid #7878ab 2px; outline: none" placeholder="Username">
                    <br>
                    <input onkeypress="javascript:sendLoginRequest(event, true)" name="password" id="create_pass" type="password" class="button" style="--bcolor: rgba(0, 0, 0, 0); --fsize: 15px; padding: 10px 5px; border-top: none; border-right: none; border-left: none; border-bottom: solid #7878ab 2px; outline: none" placeholder="Password">
                    <br>
                    <div id="createResult" style="font-size: 10px; color: #aa2222; z-index: 6">
                        <br>
                    </div>
                </div>
            </div>
        </div>

        <!-- User-specific objects and such over here -->
        <div id="userpanel" style="position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-image: url('static/sagstarcloud.JPG'); background-size: 100%; width: 30%; height: 45%; border: 0px solid #ddd; display: none; z-index: 5">
            <input type="button" class="button" value="X" style="--bcolor: #aa2222; --fsize: 7px; padding: 0 0; margin: 0 0; position: fixed; left: 0%; top: 0%; display: inline; width: 3%; height: 4%; outline: none; border: 1px solid black; border-radius: 100%" onclick="javascript:hideUserPanel();">

            <span style="position: fixed; left: 5%; top: 8%; font-size: 35px; font-family: Verdana; color: #77b">
                Your Objects
            </span>

            <input id="userid_button" type="button" style="--bcolor: #888; --fsize: 12px; position:fixed; left: 100%; top: 0%; transform: translate(-100%, 0%); outline: none" value="">

            <div id="userObjectsDiv" style="position: fixed; left: 5%; top: 25%; width: 85%; height:50%; background-color: rgba(50, 20, 20, 0.5); overflow-y: scroll; color: #889; font-size: 16px; text-align: left; font-family: Verdana; padding-left: 3%; padding-top: 3%">
            </div>

            <iframe id="hidden-iframe" name="hidden-iframe" style="display: none"></iframe>
            <form target="hidden-iframe" enctype="multipart/form-data" id="submitCatalogFile" action='/uploadfile' style="position: fixed; left: 5%; top: 75%; height: 20%; width: 90%; background-color: #000" method="POST">

                <input accept=".csv" name="catalogFileUpload" id="catalogFileUpload" type="file" style="left: 5%; top: 80%; position: fixed; color: #fff">

                <input type="hidden" name="uploadFileUser" id="uploadFileUser" value=''>
                <input type="hidden" name="uploadFilePass" id="uploadFilePass" value=''>

                <input onclick="javascript:resetFileUpload(this.form); setTimeout(populateUserObjects, 750)" type="button" class="button" style="--bcolor: #666; --fsize: 10px; position: fixed; left: 70%; top: 78%; padding: 5 5" value="Upload">
            </form>

            <span style="position: fixed; left: 5%; top: 90%; color: #ccc; font-family: Helvetica; font-size: 11px">
                All files should be .csv, with format "name,hh:mm:ss.ss,dd:mm:ss.ss"
            </span>

        </div>

        <!-- the main script begins here -->

        <gui id='gui'>
        <script>
            astrojs.ready(function(e){

            });

            //deal with the controls on/off situation
            c = document.getElementById("controls");
            if (GetURLParameter("controls") == "true"){
                c.value = "false"
            }
            else{
                c.value = "true"
            }

            //remove the antenna interface if the location is not the ATA
            if (GetURLParameter("loc") != "Allen+Telescope+Array" || GetURLParameter("controls") == "true"){
                document.getElementById("antennae").innerHTML = ''
            }

            //flash a warning message if interactive mode is on
            if (GetURLParameter("controls") == "true"){
                swal("Interactive Mode Note", "Interactive mode is still being worked on, and might be a little buggy. It's also not easily compatible with the antenna view - please revert back to non-interactive before using the antennae buttons.", "warning")
            }

            //this variable is used to animate - i.e., 10 minutes per second...
            var continuousDelayAnimateInterval;

            //and this function makes use of the previous variable
            function delayAnimate(event){
                if (event.keyCode == 13 || event.which == 13){
                    clearInterval(continuousDelayAnimateInterval);
                    if (document.getElementById("cont_del_box").value*1 != 0){
                        val = document.getElementById("cont_del_box").value;
                        continuousDelayAnimateInterval = setInterval(function(){
                            offsetRA(val/40, 100)
                        }, 100)
                    }
                }
            }

            //this function is used to get parameters from the page URL
            function GetURLParameter(sParam){

                var sPageURL = window.location.search.substring(1);
                var sURLVariables = sPageURL.split('&');

                for (var i = 0; i < sURLVariables.length; i++){

                    var sParameterName = sURLVariables[i].split('=');
                    if (sParameterName[0] == sParam) {
                        return sParameterName[1];
                    }
                }
            }

            //this function takes the values of the alt, az, and fov box, and parses them for use
            function dealWithAltAzInput(event){
                if (event.keyCode == 13 || event.which == 13){
                    alt_box = document.getElementById("alt_box");
                    az_box = document.getElementById("az_box");
                    fov_box = document.getElementById("fov_box");
                    if (alt_box.value == ''){
                        alt_box.value = 90
                    }
                    if (az_box.value ==''){
                        az_box.value = 0
                    }
                    if (fov_box.value ==''){
                        fov_box.value = 90
                    }
                    pointing_alt = alt_box.value;
                    temp_az = parseFloat(az_box.value) * 1;
                    pointing_az = temp_az
                    fov = fov_box.value;
                }
            }

            //this function takes the input in the offset box and applies it
            function customRaOffset(event){
                if (event.keyCode == 13 || event.which == 13){
                    delaybox = document.getElementById("delaybox");
                    offsetRA(delaybox.value/4);
                }
            }

            var loc = "{{ loc_here }}";
            var longitude = {{ longitude_here }};

            var atnfcheckbox = document.getElementById("drawatnf");
            var frbcheckbox = document.getElementById("drawfrb");
            var messiercheckbox = document.getElementById("drawmessier");
            var satellitecheckbox = document.getElementById("drawsatellites");
            var rratcheckbox = document.getElementById("drawrrat");
            var nvsscheckbox = document.getElementById("drawnvss");
            var flightcheckbox = document.getElementById("drawflights");
            var importantcheckbox = document.getElementById("drawimportant");
            var catboxlist = [atnfcheckbox, frbcheckbox, messiercheckbox, rratcheckbox, nvsscheckbox];
            var catnames = ["ATNF Catalog", "FRB Catalog", "Messier Catalog", "RRAT Catalog", "NVSS Catalog"];
            var catshorthands = ["atnf", "frb", "messier", "rrat", "nvss"]
            var catcolors = [0xff0000, 0x00ff00, 0x00aaff, 0xffff00, 0x9400d3];
            for (var i = 0; i < catboxlist.length; i++){
                window[catnames[i]+"_list"] = [];
            }

            function dealWithCheckboxes(){

                for (var iter = 0; iter < catboxlist.length; iter++){
                    box = catboxlist[iter];
                    if (box.checked){
                        if (window[catnames[iter]+"_list"].length > 0){
                            if (box == nvsscheckbox){
                                dealWithNVSSSlider();
                            }
                            else{
                                for (var j = 0; j < window[catnames[iter]+"_list"].length; j++){
                                    window[catnames[iter]+"_list"][j].visible = true;
                                    window[catnames[iter]+"_list"][j].hid_override = false;
                                }
                            }
                        }
                        else{
                          if (catnames[iter] == "NVSS Catalog"){
                            drawObjects(window[catshorthands[iter]+"_thetas"], window[catshorthands[iter]+"_phis"], catcolors[iter], '', group=catnames[iter], false, false, 7, true, true);
                          }
                          else{
                            drawObjects(window[catshorthands[iter]+"_thetas"], window[catshorthands[iter]+"_phis"], catcolors[iter], '', group=catnames[iter]);
                          }
                        }
                    }
                    else{
                        if (window[catnames[iter]+"_list"].length > 0){
                            for (var j = 0; j < window[catnames[iter]+"_list"].length; j++){
                                window[catnames[iter]+"_list"][j].visible = false;
                                window[catnames[iter]+"_list"][j].hid_override = true;
                            }
                        } 
                    }
                }

                if (satellitecheckbox.checked){
                    updateSatellites();
                    clearInterval(satelliterefreshID);
                    satelliterefreshID = setInterval(updateSatellites, 1000);
                }
                else{
                    clearInterval(satelliterefreshID);
                    satellite_list = []
                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].name == "Satellite" || scene.children[i].group == "Satellite")
                            scene.remove(scene.children[i]);
                    }              
                }

                if (importantcheckbox.checked){
                    obj = 0; 
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "Important Objects"){
                            scene.children[i].visible = true;
                            scene.children[i].hid_override = false;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        addObjectLabels();
                    }
                }
                else{
                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].group == "Important Objects"){
                            scene.children[i].visible = false;
                            scene.children[i].hid_override = true;
                        }
                    }             
                }
            }


            flightUpdateInterval = ''
            function dealWithFlightCheckbox(){
                if (flightcheckbox.checked){
                    updateFlights()
                    flightUpdateInterval = setInterval(updateFlights, 15000);
                }
                else{
                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].group == "Flights"){
                            namedObjectList = namedObjectList.filter(element => !element.includes(scene.children[i].name))
                            scene.remove(scene.children[i])
                        }
                    }
                    clearInterval(flightUpdateInterval)
                }
            }

            function dealWithNVSSSlider(){
                if (nvsscheckbox.checked){
                    min_val = document.getElementById("nvss_slider").value * 1
                    document.getElementById("fornvss").innerHTML = "NVSS Catalog (>" + min_val +" Jy)"
                    for (var i = 0; i < window["NVSS Catalog_list"].length; i++){
                        if (nvss_lum[i] >= min_val*1000){
                            window["NVSS Catalog_list"][i].visible = true;
                            window["NVSS Catalog_list"][i].hid_override = false;
                        }
                        else{
                            window["NVSS Catalog_list"][i].visible = false;
                            window["NVSS Catalog_list"][i].hid_override = true;
                        }
                    }
                }

            }

            function nvssDialogue(){
              if (nvsscheckbox.checked){
                document.getElementById("fornvss").innerHTML = 'Loading Objects...'
              }
              setTimeout(dealWithCheckboxes, 200)
              setTimeout(function(){document.getElementById("fornvss").innerHTML = 'NVSS Catalog (>0.2 Jy)'}, 1000)

            }

            function gridCheckboxes(){
                altazcheckbox = document.getElementById("altazcheckbox");
                equatorialcheckbox = document.getElementById("equatorialcheckbox");

                if (equatorialcheckbox.checked){
                    obj = 0;
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "equatorial"){
                            scene.children[i].visible = true;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        addRALines();
                        writeRALabels();
                        addDecLines();
                        writeDecLabels();
                    }
                }
                else{
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "equatorial")
                            scene.children[i].visible = false;
                    }    
                }

                if (altazcheckbox.checked){
                    obj = 0;
                    for (let i = camera.children.length - 1; i >= 0; i--) {
                        if(camera.children[i].group == "altaz"){
                            camera.children[i].visible = true;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        drawAltAz(0, 0, 0);
                    }
                }
                else{
                    for (let i = camera.children.length - 1; i >= 0; i--){
                        if (camera.children[i].group == "altaz")
                            camera.children[i].visible = false;
                    }                        
                }
            }

            function calculateSiderealTime(raw){
            	/*y = 2020
            	m = 8
            	day = 19

            	dwhole = (367 * y) - Math.floor(7 * (y + Math.floor((m + 9) / 12)) / 4) + Math.floor(275 * m / 9) + day - 730531.5

            	dfrac_o = Math.floor(new Date().getTime()/1000) % 86400

            	hours = Math.floor(dfrac_o / 3600)

            	mins = Math.floor(dfrac_o / 60) % 60

            	seconds = dfrac_o - (hours * 3600) - (mins * 60)

            	dfrac = (hours + mins/60 + seconds/3600)/24

            	d = dwhole + dfrac

            	lmst = 280.46061837 + (360.98564736629 * d) + longitude

            	lmst = lmst * Math.PI / 180

            	if (raw){
            		return lmst
            	}*/

                //get the time in UTC
                seconds_since_j2000 = Math.floor(Date.now()/1000) - 946684800;
                if (longitude < 0){
                    longitude_east = 360 + longitude;
                }
                else {
                    longitude_east = longitude;
                }

                longitude_h = longitude_east / 15.;
                
                unixSec = Date.now() / 1000.;
                // This is from
                // https://stackoverflow.com/a/466348/3325750
                jd = (unixSec / 86400.0 ) + 2440587.5;

                // jd of Jan1 2000
                jan1_2000_jd = 2451545.0;

                ndays_per_jcentury = 36525.;

                // This if from
                // https://astronomy.stackexchange.com/a/21004/35162
                midnight = Math.floor(jd) + 0.5;
                days_since_midnight = jd - midnight;
                hours_since_midnight = days_since_midnight * 24;
                days_since_epoch = jd - jan1_2000_jd;
                centuries_since_epoch = days_since_epoch / ndays_per_jcentury;
                whole_days_since_epoch = midnight - jan1_2000_jd;
                
                GMST = 6.697374558
                     + 0.06570982441908 * whole_days_since_epoch
                     + 1.00273790935 * hours_since_midnight
                     + 0.000026 * centuries_since_epoch*centuries_since_epoch;

                siderealtime = GMST + longitude_h;
                siderealtime = siderealtime % 24;


                if (raw){
                    return (siderealtime * 15) * Math.PI / 180
                }

                else{
                    hours = Math.floor(siderealtime);
                    siderealtime = siderealtime - hours;
                    minutes = Math.floor(siderealtime*60);
                    siderealtime = siderealtime - minutes/60;
                    seconds = Math.floor(siderealtime*3600);

                    if (String(hours).length < 2){
                        hours = '0' + hours;
                    }
                    if (String(minutes).length < 2){
                        minutes = '0' + minutes;
                    }
                    if (String(seconds).length < 2){
                        seconds = '0' + seconds;
                    }

                    return hours + ":" + minutes + ":" + seconds;
                }
            }


            function fullReload() {
                sid = document.getElementById("sidtime");
                sid.innerHTML = "<input type='button' class='button' style='--bcolor: #123456; --fsize: 15px;' value=" +calculateSiderealTime(false) + ">";
                setTimeout(fullReload, 500);
            }
            fullReload()

            function startScene(){
                var width = window.innerWidth;
                var height = window.innerHeight;
                camera = new THREE.OrthographicCamera( -(r+rmod), (r+rmod), (r+rmod), -(r+rmod), 0, 1000 );
                //camera = new THREE.PerspectiveCamera( 90, 1, 1, 100000 );
                renderer = new THREE.WebGLRenderer({antialias: true});
                //renderer.setPixelRatio( pixelratio, pixelratio );
                renderer.setSize(height, height);
                document.getElementById('gui').appendChild(renderer.domElement);

                scene = new THREE.Scene({canvas:gui});
                scene.background = new THREE.Color( 0x000000 );
                scene.add(camera);
            }

            //draw RA lines

            function addDecLines(visible=true){
                angles = [0, Math.PI/6, -Math.PI/6, Math.PI/4, -Math.PI/4, Math.PI/3, -Math.PI/3, 5*Math.PI/12, -5*Math.PI/12];
                color = 0xffff00
                for (var angle = 0; angle < angles.length; angle++){
                    if (angles[angle] == 0){
                        color = 0xffa500;
                    }
                    else{
                        color = 0xffffff;
                    }
                    ring_rad = r * Math.cos(angles[angle]);
                    ring_width = 0.06
                    //var geometry = new THREE.TorusGeometry(ring_rad, ring_width/2, 16, 48);
                    var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                    //var material = new THREE.MeshBasicMaterial( { color: color } );
                    //line = new THREE.Mesh( geometry, material );
                    var edges = new THREE.EdgesGeometry( geometry );
                    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );
                    line.position.set(0, r*Math.sin(angles[angle]), 0);
                    line.rotation.setFromVector3(new THREE.Vector3(Math.PI/2, 0, Math.PI/2));
                    line.group = "equatorial";
                    //line.material.shading = THREE.SmoothShading;
                    if (visible == false){
                        line.visible = false;
                    }
                    scene.add(line);
                }
            }

            //draw DEC lines

            function addRALines(visible=true){
                color = 0xffffff;
                angles = [0, Math.PI/2];
                for (var angle = 0; angle < angles.length; angle++){
                    ring_rad = r;
                    ring_width = 0.06
                    //var geometry = new THREE.TorusGeometry(ring_rad, ring_width/2, 16, 48);
                    //var material = new THREE.MeshBasicMaterial( { color: color, side: THREE.DoubleSide } );

                    //line = new THREE.Mesh( geometry, material );
                    var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                    var edges = new THREE.EdgesGeometry( geometry );
                    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );
                    
                    line.position.set(0, 0, 0);
                    line.rotation.setFromVector3(new THREE.Vector3(0, angles[angle], angles[angle]));
                    line.group = "equatorial";
                    line.material.shading = THREE.SmoothShading;
                    if (visible==false){
                        line.visible = false;
                    }
                    scene.add(line);
                }
            }

            var scenetextobjects = [];

            function addText(text, pos, group, addtocamera=false, size=0.35, color=0x00fff8){
                var loader = new THREE.FontLoader();
                loader.load( '/static/examples/fonts/helvetiker_bold.typeface.json', function (font){
                    var textGeo = new THREE.TextGeometry( text, {
                        font: font,
                        size: size,
                        height: 0.01,
                        curveSegments: 24,
                        bevelEnabled: false

                    } );
                    var textMaterial = new THREE.MeshBasicMaterial( { color: color } );

                    var mesh = new THREE.Mesh( textGeo, textMaterial );

                    if (addtocamera==true){
                        camera.add(mesh);
                    }
                    else{
                        scene.add(mesh);
                    }
                    mesh.position.set(pos[0], pos[1], pos[2]);
                    mesh.name = "textlabel";
                    mesh.group = group;
                    if (addtocamera==false){
                      scenetextobjects.push(mesh);
                    }
                    window[text+"_text"] = mesh
                } );
            }


            var frb_thetas = {{ frb_ra_dat_here }};
            var frb_phis = {{ frb_dec_dat_here }}
            var frb_names = {{ frb_name_dat_here | safe}}

            var atnf_thetas = {{ atnf_ra_dat_here }};
            var atnf_phis = {{ atnf_dec_dat_here }};
            var atnf_names = {{ atnf_name_dat_here | safe}}

            var messier_thetas = {{ messier_ra_dat_here }};
            var messier_phis = {{ messier_dec_dat_here }};
            var messier_names = {{ messier_name_dat_here | safe }}

            var rrat_thetas = {{ rrat_ra_dat_here }}
            var rrat_phis = {{ rrat_dec_dat_here }}
            var rrat_names = {{ rrat_name_dat_here | safe }}

            var nvss_thetas = {{ nvss_ra_dat_here }};
            var nvss_phis = {{ nvss_dec_dat_here }}
            var nvss_lum = {{ nvss_lum_dat_here }}
            var nvss_names = {{ nvss_name_dat_here | safe }}

            function createCircleTexture(color, size=400, group) {
                var matCanvas = document.createElement('canvas');
                matCanvas.width = matCanvas.height = size;
                var matContext = matCanvas.getContext('2d');
                // create texture object from canvas.
                var texture = new THREE.Texture(matCanvas);
                // Draw a circle
                var center = size / 2;
                matContext.beginPath();
                matContext.shadowBlur = 100;
                matContext.shadowColor = 'white';
                matContext.arc(center, center, 70, 0, 2 * Math.PI, false);
                matContext.fillStyle = color;
                matContext.fill();

              // need to set needsUpdate
                texture.needsUpdate = true;
              // return a texture made from the canvas
                return texture;
            }

            function drawObjects(thetas, phis, color, name, group='', listofnames=false, satellitemode=false, size=7, visible=true, nvss=false, do_not_push=false, flight=false, alts='') {
                color = "#" + color.toString(16).padStart(6, '0');
                if (name != "Satellite" && group != "Satellite" && group != "Flights")
                    thistexture = createCircleTexture(color, 400, group);
                for (var i = 0; i < thetas.length; i++){
                    origtheta = thetas[i];
                    origphi = phis[i];
                    theta = thetas[i];
                    phi = phis[i];

                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);

                    if (flight){
                        /*x = x
                        y = y
                        z = z
                        x *= alts[i] / 10000
                        y *= alts[i] / 10000
                        z *= alts[i] / 10000*/
                    }

                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(new THREE.Vector3(0, 0, 0))
                    if (name == "Satellite" || group == "Satellite" || group == "Flights")
                        var material = new THREE.PointsMaterial( { size: 2, sizeAttenuation: false, color: color } );
                    else
                        var material = new THREE.PointsMaterial({
                                      size: size,
                                      map: thistexture,
                                      transparent: true,
                                      depthWrite: false
                                    });
                    var point = new THREE.Points( geometry, material );
                    if (listofnames==true){
                        point.name = name[i]
                    }
                    else{
                        point.name = name;
                    }

                    if (nvss || group == "NVSS Catalog"){

                      theta = theta * 24 / (2 * Math.PI) //get the hours
                      theta_hour = Math.trunc(theta)
                      if (String(theta_hour).length == 1){
                        theta_hour = "0"+theta_hour
                      }

                      theta = theta - theta_hour //get the minutes
                      theta = 60 * theta
                      theta_minute = Math.trunc(theta)
                      if (String(theta_minute).length == 1){
                        theta_minute = "0"+theta_minute
                      }

                      theta = theta - theta_minute //get the seconds
                      theta = 60 * theta
                      theta = Math.trunc(theta)
                      if (String(theta).length == 1){
                        theta = "0"+theta
                      }

                      phi = phi * 180 / (Math.PI) //get the declination degrees
                      phi = phi + 90 //make all phis positive, makes it easier to deal with minutes and seconds
                      phi_degree = Math.trunc(phi)
                      if (String(phi_degree).length == 1){
                        phi_degree = "0"+phi_degree
                      }

                      phi = phi - phi_degree

                      phi_degree = phi_degree - 90
                      if (String(phi_degree).length == 1){
                        phi_degree = "0"+phi_degree
                      }
                      if (String(Math.abs(phi_degree)).length == 1 && phi_degree < 0){ //deal with negative dec
                        phi_degree = "-0"+Math.abs(phi_degree)
                      }
                      if (phi_degree > 0){
                        phi_degree = "+" + phi_degree
                      }

                      phi = 60 * phi // get the declination minutes
                      phi_minute = Math.trunc(phi)
                      phi = phi - phi_minute
                      if (String(phi_minute).length == 1){
                        phi_minute = "0" + phi_minute
                      }

                      phi = phi * 60
                      phi = Math.trunc(phi) //get the declination seconds
                      if (String(phi).length == 1){
                        phi = "0" + phi
                      }

                      point.name = "NVSS J"+theta_hour+theta_minute+theta+phi_degree+phi_minute+phi
                      point.lum = nvss_lum[i]
                    }

                    if (group != ''){
                        point.group = group;
                        if (group.includes("Catalog") || group.includes("udef_"))
                            window[group+"_list"].push(point)
                    }

                    if (satellitemode == true){
                        point.sat_tag = i;
                        
                        if (listofnames==true){
                            satellite_list.push(name[i]);
                            window[name[i]] = point;
                        }
                        else{
                            satellite_list.push(name);
                            window[name] = point;
                        }
                    }

                    point.theta = origtheta
                    point.phi = origphi
                    point.visible = visible;
                    scene.add(point);

                    point.position.set(x,y,z);

                    if (!do_not_push){
                      namedObjectList.push(point.name)
                    }
                    window[point.name] = point;
                }
            }



            var dec = {{ declination_here }} * Math.PI / 180;
            var ra = 0;

            //write declination labels
            function writeDecLabels(visible=true){
                labels = [-5*Math.PI/12, -Math.PI/3, -Math.PI/4, -Math.PI/6, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];
                for (var i = 0; i < labels.length; i++){
                    shift = 0.2;
                    mainaxis = r * Math.cos(labels[i]);
                    elev = shift + r * Math.sin(labels[i]);
                    deg_angle = Math.round(labels[i] * 180 / Math.PI)
                    addText(deg_angle+String.fromCharCode("0176"), [mainaxis, elev, shift], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [-shift, elev, mainaxis], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [-mainaxis, elev, -shift], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [shift, elev, -mainaxis], "equatorial");
                }
            }

            //write ra labels
            function writeRALabels(visible=true){
                labels = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                for (var i = 0; i < labels.length; i++){
                    angle = labels[i];
                    hour = angle * 180 / Math.PI;
                    hour = Math.round(hour/15);

                    addText(String(hour)+'h', [r*Math.cos(angle)+0.2, 0.2, r*Math.sin(angle)], "equatorial");
                }
            }

            var sun;
            var sun_halo;
            function drawSun(){
                /*seconds_since_j2000 = Math.floor(Date.now()/1000) - 946684800;

                seconds = seconds_since_j2000 % 86400;

                hours = Math.floor(seconds/3600);
                minutes = Math.floor(seconds/60) - hours*60;
                seconds = seconds - minutes*60 - hours*3600;

                days_since_j2000 = seconds_since_j2000 / 86400;

                //other calculations 
                L = 280.460 + (0.9856474 * days_since_j2000)
                g = 357.528 + (0.9856003 * days_since_j2000)
                L = L % 360
                g = g % 360
                lambda = L + (1.915 * Math.sin(g * Math.PI/180)) + (0.02 * Math.sin(2 * g * Math.PI/180));

                obl_earth = 23.43661;

                ra_sun = Math.atan2(Math.cos(obl_earth*Math.PI/180) * Math.sin(lambda*Math.PI/180), Math.cos(lambda*Math.PI/180));
                dec_sun = Math.asin(Math.sin(obl_earth*Math.PI/180) * Math.sin(lambda*Math.PI/180));*/

                var sun_pos = new XMLHttpRequest;
                sun_pos.open("GET", "/getsunpos?offset=" + (raoffset * 24 / (2*Math.PI)))
                sun_pos.send()

                sun_pos.onreadystatechange = function(){
                    if (this.readyState == 4 && this.status == 200){
                        ra_sun = this.responseText.split(",")[0] * 1
                        dec_sun = this.responseText.split(",")[1] * 1
                        sun_x = r * Math.cos(ra_sun) * Math.cos(dec_sun);
                        sun_y = r * Math.sin(dec_sun);
                        sun_z = r * Math.sin(ra_sun) * Math.cos(dec_sun);

                        sun_rad = 2 * Math.PI * r * 0.25/360;
                        sun_halo_rad = sun_rad * 20;

                        var geometry = new THREE.SphereGeometry(sun_rad, 32, 32);
                        var halo_geometry = new THREE.CircleGeometry(sun_halo_rad, 32)

                        var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                        var halo_material = new THREE.MeshBasicMaterial( {color: 0xffff00, transparent: true, opacity: 0.3} );

                        scene.remove(sun)
                        scene.remove(sun_halo)

                        sun = new THREE.Mesh( geometry, material );
                        sun_halo = new THREE.Mesh( halo_geometry, halo_material );

                        sun.position.set(sun_x, sun_y, sun_z);
                        sun_halo.position.set(sun_x, sun_y, sun_z);
                        sun_halo.lookAt(camera.position)

                        scene.add(sun);
                        scene.add(sun_halo);
                        sun.name = "Sun"
                        sun_halo.name = "Sun"

                        sun.theta = ra_sun
                        sun.phi = dec_sun

                        window["Sun"] = sun
                        namedObjectList.push("Sun")
                    }
                }

            }

            var moon;
            var moon_halo;
            function drawMoon(){

                var moon_pos = new XMLHttpRequest;
                moon_pos.open("GET", "/getmoonpos?offset=" + (raoffset * 24 / (2*Math.PI)))
                moon_pos.send()
                moon_pos.onreadystatechange = function(){
                    if (this.readyState == 4 && this.status == 200){
                        moon_ra = this.responseText.split(",")[0] * 1
                        moon_dec = this.responseText.split(",")[1] * 1

                        moon_rad = 2 * Math.PI * r * 0.25/360;
                        moon_halo_rad = moon_rad * 10;

                        var geometry = new THREE.SphereGeometry(moon_rad, 32, 32);
                        var halo_geometry = new THREE.CircleGeometry(moon_halo_rad, 32)

                        var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
                        var halo_material = new THREE.MeshBasicMaterial( {color: 0xffffff, transparent: true, opacity: 0.3} );

                        scene.remove(moon);
                        scene.remove(moon_halo);

                        moon = new THREE.Mesh( geometry, material );
                        moon_halo = new THREE.Mesh( halo_geometry, halo_material );   

                        moon_x = r * Math.cos(moon_ra) * Math.cos(moon_dec);
                        moon_y = r * Math.sin(moon_dec);
                        moon_z = r * Math.sin(moon_ra) * Math.cos(moon_dec);

                        var mult = 1;

                        moon.position.set(moon_x*mult, moon_y*mult, moon_z*mult);
                        moon_halo.position.set(moon_x*mult, moon_y*mult, moon_z*mult);
                        moon_halo.lookAt(camera.position)

                        scene.add(moon);
                        scene.add(moon_halo);
                        moon.name = "Moon"
                        moon_halo.name = "Moon"

                        moon.theta = moon_ra
                        moon.phi = moon_dec

                        window["Moon"] = moon
                        namedObjectList.push("Moon")
                    }
                }
            }

            var ra = 0;
            var timeoffset = 0;
            var raoffset = 0;
            var raoffset_raw = 0;
            var raoffsetdelta = Math.PI/180;

            function offsetRA(change, reset=false){
                satbox = satellitecheckbox = document.getElementById("drawsatellites");
                
                raoffset += change * Math.PI/180;
                raoffset_raw += change*4
                if (reset==true){
                    raoffset = 0;
                    raoffset_raw = 0;
                }
                timeoffset = raoffset_raw;
                if (satbox.checked){
                    //clearInterval(satelliterefreshID);
                    updateSatellites();
                }

                //get the decimal places right with some float to string and then back to float conversion
                //raoffset_raw = (1 * raoffset_raw).toFixed(3);
                //raoffset_raw = 1 * raoffset_raw;
                //raoffset_raw = raoffset_raw.toString();

                d = document.getElementById("totaloffset");
                d.innerHTML = "<input type='button' class='button' style='--bcolor: #444444; --fsize: 15px;' value='Total Time Offset (min): " + raoffset_raw.toFixed(2) + "'>";

                drawSun();
                drawMoon();
            }

            var ra;
            var mask = '';
            var pointing_az;
            var pointing_alt;
            var antenna = GetURLParameter("antenna");
            //create dummy event to pass to function
            var e = new Object();
            e.keyCode = 13;
            e.which = 13;

            var alt_box = document.getElementById("alt_box");
            var az_box = document.getElementById("az_box");
            var fov_box = document.getElementById("fov_box");
            alt_box.value = GetURLParameter('alt');
            az_box.value = GetURLParameter('az');
            fov_box.value = GetURLParameter('fov');

            var pointing_alt = alt_box.value;
            var pointing_az = az_box.value;
            var fov = fov_box.value;

            dealWithAltAzInput(e);

            function updateAltAz(this_antenna){
                if (this_antenna == "none"){
                   
                }
                else{
                    var alt_box = document.getElementById("alt_box");
                    var az_box = document.getElementById("az_box");
                    var fov_box = document.getElementById("fov_box");
                    altaz = getAntennaData(this_antenna)
                    pointing_alt = altaz[0]
                    pointing_az = altaz[1]
                    alt_box.value = pointing_alt;
                    az_box.value = pointing_az;
                    fov_box.value = 90; 
                }
            }
            var current_antenna_interval = setInterval(function () {
                updateAltAz(antenna);
                //dealWithAltAzInput(e);
            }, 500);

            function changeAntenna(new_antenna=''){
                new_antenna = document.getElementById("antenna_select").value;
                antenna = new_antenna
                updateAltAz(new_antenna);
                dealWithAltAzInput(e);
                clearInterval(current_antenna_interval);
                if (new_antenna == "none"){
                    var alt_box = document.getElementById("alt_box");
                    var az_box = document.getElementById("az_box");
                    var fov_box = document.getElementById("fov_box");  
                    alt_box.value = 90;
                    az_box.value = 0;
                    fov_box.value = 90;  
                    dealWithAltAzInput(e);
                    current_antenna_interval = ''
                }
                else{
                    current_antenna_interval = setInterval(function () {
                        updateAltAz(new_antenna);
                        dealWithAltAzInput(e);
                    }, 500);
                }
            }

            function redoAltAz(x, y, z){
                angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];
                for (var i = scene.children.length - 1; i >= 0; i--) {
                    if(scene.children[i].group == "altaz"){
                        if (scene.children[i].name == "textlabel"){
                            //scene.remove(scene.children[i]);
                        }
                        else{
                            scene.children[i].lookAt(x, y, z);
                        }
                    }
                }
            }

            function drawAltAz(x, y, z){

                angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];

                var helper = new THREE.PolarGridHelper( r, 16, 1, 64 );
                camera.add( helper );
                helper.group = "altaz"
                helper.position.set(0, 0, -20)
                for (i = 1; i < angles.length; i++){ //skip 0
                    var geometry  = new THREE.CircleGeometry( r*Math.cos(angles[i]), 36)
                    var edges = new THREE.EdgesGeometry(geometry)
                    var circle = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x888888 } ))
                    circle.position.set(0, 0, 0)
                    circle.rotation.set(Math.PI/2, 0, 0)

                    helper.add(circle)
                }
                helper.rotation.set(0, Math.PI/2, Math.PI/2)
                /*var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                var edges = new THREE.EdgesGeometry( geometry );
                var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );*/

                //draw the degree labels
                for (i = 0; i < angles.length; i++){
                    a = Math.round(angles[i] * 180 / Math.PI);
                    temprad = r*Math.cos(angles[i]);
                    xyangle = Math.PI/4;
                    x = temprad * Math.sin(xyangle);
                    y = temprad * Math.cos(xyangle)
                    addText(a+String.fromCharCode("0176"), [x, y, -1], "altaz", addtocamera=true);
                }

                //label North
                addText("N", [0.1, 9.5, -1], "altaz", addtocamera=true);

                //label East
                addText("E", [9.5, 0.1, -1], "altaz", addtocamera=true);
            }

            function redoLabels(){
                /*for (var i = scene.children.length - 1; i >= 0; i--) {
                    if(scene.children[i].name == "textlabel"){
                        scene.children[i].quaternion.copy(camera.quaternion);
                    }
                }*/
                for (var i = 0; i < scenetextobjects.length; i++){
                    scenetextobjects[i].quaternion.copy(camera.quaternion);
                    if (scenetextobjects[i].spec == "crosshair"){
                      continue;
                    }
                    scenetextobjects[i].scale.set(1 / camera.zoom, 1 / camera.zoom, 1 / camera.zoom);
                }
            }

            var data = '';
            var satellite_list = [];
            function drawSatellites(){
                xdata = new XMLHttpRequest();
                xdata.open("GET", "/static/newtle.txt?time="+new Date().getTime());
                xdata.send();
                xdata.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        data = this.responseText;
                        data = data.split("\n0");
                        //data = data.filter(element => element.includes("STARLINK"));
                    }
                };
            }

            function updateSatellites(){
 
                for (var i = 0; i < data.length; i+=1){
                    var sat = data[i].split("\n")
                    name = sat[0];

                    line1 = sat[1];
                    line2 = sat[2];

                    var satrec = satellite.twoline2satrec(line1, line2);

                    var oldDateObj = new Date();
                    var newDateObj = new Date();
                    newDateObj.setTime(oldDateObj.getTime() + (timeoffset * 60 * 1000));

                    //var timeSinceTleEpochMinutes = Math.floor(new Date().getTime() / 60000);

                    //var positionAndVelocity = satellite.sgp4(satrec, timeSinceTleEpochMinutes);
                    var positionAndVelocity = satellite.propagate(satrec, newDateObj);

                    var positionEci = positionAndVelocity.position,
                        velocityEci = positionAndVelocity.velocity;

                    if (positionEci == undefined){
                      continue;
                    }

                  

                    var observerGd = {
                        longitude: satellite.degreesToRadians(longitude),
                        latitude: satellite.degreesToRadians(dec),
                        height: 0.370
                    };

                    var gmst = satellite.gstime(new Date());

                    var positionGd = satellite.eciToGeodetic(positionEci, gmst);

                    var satlongitude = positionGd.longitude,
                        satlatitude  = positionGd.latitude;

                    //if ( Math.abs(satlatitude - dec) < 0.1 && Math.abs(satlongitude - ra) < 0.1){
                    if (satellite_list.includes(name)){
                        var pos = thetaPhiToXYZ(satlongitude, satlatitude)
                        window[name].position.x = pos[0]
                        window[name].position.y = pos[1]
                        window[name].position.z = pos[2]
                    }
                    else{
                        drawObjects([satlongitude], [satlatitude], 0xffffff, [name], "Satellite", true, true);
                    }
                    //}
                    
                }
            }

            var e_c_eq = 40075.017
            var e_c_pol = 39940.653
            var e_c_av = (e_c_pol + e_c_eq) / 2

            if ("{{ loc_here }}" == "Allen Telescope Array"){
                var obs_site_elev = 1000
            }
            else{
                var obs_site_elev = 0
            }

            function updateFlights(){
                var flight_data_req = new XMLHttpRequest;
                flight_data_req.open("GET", "/static/flightdata.txt?time=" + new Date().getTime())
                flight_data_req.send();
                flight_data_req.onreadystatechange = function(){
                    var flight_data = this.responseText;
                    var spl = flight_data.split("$")
                    flight_lats = spl[0].split(",")
                    flight_long = spl[1].split(",")
                    flight_alts = spl[2].split(",")
                    flight_call = spl[3].split(",")

                    final_lats = [];
                    final_long = [];
                    final_call = [];

                    //calculate the offset for RA vs longitude

                    for (var i = 0; i < flight_lats.length; i++){
                        var d_lat = (flight_lats[i] * 1) - (dec * 180 / Math.PI)
                        var d_long = (flight_long[i] * 1) - (longitude)
                        var orig_d_long = d_long

                        var n_d_long = d_long
                        if (d_long > 180){
                            var n_d_long = 360 - d_long
                        }
                        if (d_long < -180){
                            var n_d_long = (-360) - d_long
                        }

                        d_long = n_d_long


                        var ground_d_long = (d_long / 360) * Math.cos(flight_lats[i] * Math.PI / 180) * e_c_eq
                        var ground_d_lat = (d_lat / 360) * e_c_pol
                        var ground_dist = Math.sqrt(ground_d_lat*ground_d_lat + ground_d_long*ground_d_long)

                        if (ground_dist > 100){
                            //check for >100km distance
                            continue
                        }

                        console.log(d_lat*1, d_long, orig_d_long)

                        var quadrant = 0 //we need to specify what quadrant the azimuth is in 
                        //since regular trig functions are only two-quadrant

                        if (d_lat > 0){ //this narrows it to quadrant 1 or 2
                            if (d_long > 0){
                                quadrant = 1
                            }
                            else{
                                quadrant = 2
                            }
                        }
                        if (d_lat < 0){ //this narrows it to quadrant 3 or 4
                            if (d_long > 0){
                                quadrant = 4
                            }
                            else{
                                quadrant = 3
                            }
                        }

                        var flight_az = Math.abs((Math.atan(d_lat / d_long) * (180 / Math.PI))) % 90
                        //now, modify for the quadrant
                        flight_az = flight_az + (90 * (quadrant - 1))

                        var flight_altitude = Math.abs(Math.atan(((flight_alts[i] - obs_site_elev) * 1/1000) / ground_dist) * (180 / Math.PI))

                        //convert back to radians
                        flight_az = flight_az * Math.PI / 180
                        flight_altitude = flight_altitude * Math.PI / 180


                        var flight_final_dec = Math.asin( Math.sin(flight_altitude) * Math.sin(dec) + Math.cos(flight_altitude) * Math.cos(dec) * Math.cos(flight_az))

                        var final_H = Math.asin( -Math.sin(flight_az) * Math.cos(flight_altitude) / Math.cos(flight_final_dec) )

                        if ((flight_az*180/Math.PI > 270 || flight_az*180/Math.PI < 90)){
                            final_H = final_H + (Math.PI/2 - final_H)*2
                        }

                        var flight_final_ra = (calculateSiderealTime(true) % (2 * Math.PI)) - final_H


                        console.log(flight_final_ra, flight_final_dec, flight_call[i])
                        final_long.push(flight_final_ra)
                        final_lats.push(flight_final_dec)
                        final_call.push(flight_call[i])
                        //now convert from alt-az into ra-dec
                    }

                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].group == "Flights"){
                            scene.remove(scene.children[i])
                        }
                    }

                    drawObjects(final_long, final_lats, 0xaaaaaa, final_call, "Flights", true, false, 7, true, false, false, true, flight_alts);
                }
            }

            function processRaDec(right_asc, decl){
                right_asc = (right_asc[0] * 15) + (right_asc[1] / 4) + (right_asc[2] / 240);
                decl = (decl[0]) + (decl[1] / 60) + (decl[2] / 3600);

                right_asc = + right_asc * Math.PI / 180;
                decl = decl * Math.PI / 180;

                x = r * Math.cos(right_asc) * Math.cos(decl);
                y = r * Math.sin(decl);
                z = r * Math.sin(right_asc) * Math.cos(decl);

                return [x, y, z, right_asc, decl];
            }

            function thetaPhiToXYZ(theta, phi){
                x = r * Math.cos(theta) * Math.cos(phi)
                y = r * Math.sin(phi)
                z = r * Math.sin(theta) * Math.cos(phi)
                return [x, y, z]
            }

            //add significant object labels
            importantObjectList = [];
            function addObjectLabels(){
                //Crab Pulsar
                importantObjectList.push("Crab Pulsar")
                right_asc = [5, 34, 31.973];
                decl = [22, 0, 52.06];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("Crab Pulsar", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'Crab Pulsar', group="Important Objects")

                //J0332+5434
                importantObjectList.push("J0332+5434")
                right_asc = [3, 32, 59.4096];
                decl = [54, 34, 43.329];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("J0332+5434", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'J0332+5434', group="Important Objects")

                //SGR 1935+2154
                importantObjectList.push("SGR 1935+2154")
                right_asc = [19, 35, 0];
                decl = [21, 54, 0];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("SGR 1935+2154", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'SGR 1935+2154', group="Important Objects")

                //Jupiter
                importantObjectList.push("Jupiter")
                jup_ra = {{ jup_ra }}
                jup_dec = {{ jup_dec }}

                l = thetaPhiToXYZ(jup_ra, jup_dec);
                x = l[0];
                y = l[1];
                z = l[2];

                addText("Jupiter", [x, y + 0.001, z], "Important Objects", false, 0.2)
                drawObjects([jup_ra], [jup_dec], 0x00fff8, 'Jupiter', group="Important Objects")

                //Jupiter
                importantObjectList.push("Saturn")
                sat_ra = {{ sat_ra }}
                sat_dec = {{ sat_dec }}

                l = thetaPhiToXYZ(sat_ra, sat_dec);
                x = l[0];
                y = l[1];
                z = l[2];

                addText("Saturn", [x, y + 0.001, z], "Important Objects", false, 0.2)
                drawObjects([sat_ra], [sat_dec], 0x00fff8, 'Saturn', group="Important Objects")

            }

            var antenna_azel_data;
            //get initial antenna data, populate dropdown menu
            var antenna_req = new XMLHttpRequest();        
            antenna_req.open("GET", "/antennadata/azel");
            antenna_req.send();
            var alt;
            var az;
            var adata;
            antenna_req.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    adata = this.responseText;
                    adata = JSON.parse(adata)
                    antenna_azel_data = adata;
                    var keys = [];
                    for (var k in adata){
                      document.getElementById("antenna_select").innerHTML += "<option value='"+k+"'>"+k+"</option>"
                    }
                }
            };

            var antenna_azel_data;
            //this is to actually get the antenna data for each option
            function getAntennaData(this_antenna, single=true){
                var antenna_req = new XMLHttpRequest();        
                antenna_req.open("GET", "/antennadata/azel");
                antenna_req.send();
                var alt;
                var az;
                antenna_req.onreadystatechange = function() {
                  if (this.readyState == 4 && this.status == 200) {
                      adata = this.responseText;
                      adata = JSON.parse(adata)
                      antenna_azel_data = adata; //keep this global so we can access it from other functions
                  }
                };
                if (single){
                    return [antenna_azel_data[this_antenna]["el"], antenna_azel_data[this_antenna]["az"]]
                }
                else{
                    return antenna_azel_data
                }
            }


            obs_antenna_list = ['1a (simulated)', '1a', '1f', '1c', '2a', '2b', '2h', '3c', '4g', '1k', '5c']
            var drawnAntennasList = [];
            //draw antenna crosshairs on the sky
            function updateAntennaCrosshairs(){
                //var full_antenna_data = getAntennaData('', false);
                
                var full_antenna_data = antenna_azel_data

                var antenna_list = Object.keys(full_antenna_data);
                for (var i = 0; i < antenna_list.length; i++){
                    var curr_ant = antenna_list[i]
                    if (obs_antenna_list.includes(curr_ant)){
                        var ant_az = full_antenna_data[curr_ant]['az'] * 1 
                        var ant_alt = full_antenna_data[curr_ant]['el'] * 1

                        var ant_dec = Math.asin( Math.sin(ant_alt * Math.PI / 180) * Math.sin(dec) + Math.cos(ant_alt * Math.PI / 180) * Math.cos(dec) * Math.cos(ant_az * Math.PI / 180))

                        var ant_h = Math.asin( -Math.sin(ant_az * Math.PI / 180) * Math.cos(ant_alt * Math.PI / 180) / Math.cos(ant_dec) )

                        if ((ant_az > 270 || ant_az < 90)){
                            ant_h = ant_h + (Math.PI/2 - ant_h)*2
                        }

                        var ant_ra = (calculateSiderealTime(true) + raoffset - ant_h) % (2 * Math.PI)

                        var ant_x = r * Math.cos(ant_ra) * Math.cos(ant_dec);
                        var ant_y = r * Math.sin(ant_dec);
                        var ant_z = r * Math.sin(ant_ra) * Math.cos(ant_dec);
                        
                        var ant_rad = 2 * Math.PI * r * (1.2 / 360);

                        var ant_mat = new THREE.LineBasicMaterial( {color: 0xff0000} )
                        var ant_geo = new THREE.Geometry();

                        var ant_marker_size = 0.25

                        ant_geo.vertices.push(new THREE.Vector3(ant_marker_size, 0, 0));
                        ant_geo.vertices.push(new THREE.Vector3(ant_marker_size, 0, 0));
                        ant_geo.vertices.push(new THREE.Vector3(-ant_marker_size, 0, 0));
                        ant_geo.vertices.push(new THREE.Vector3(0, 0, 0));
                        ant_geo.vertices.push(new THREE.Vector3(0, -ant_marker_size, 0));
                        ant_geo.vertices.push(new THREE.Vector3(0, ant_marker_size, 0));
                        //var ant_geometry = new THREE.CircleGeometry(ant_rad, 32)

                        //var ant_material = new THREE.MeshBasicMaterial( {color: 0xff0000, transparent: true, opacity: 0.3} );

                        scene.remove(window[curr_ant+"_ant_marker"])

                        window[curr_ant+"_ant_marker"] = new THREE.Line(ant_geo, ant_mat);

                        window[curr_ant+"_ant_marker"].position.set(ant_x, ant_y, ant_z)
                        window[curr_ant+"_ant_marker"].quaternion.copy(camera.quaternion)
                        window[curr_ant+"_ant_marker"].group = "antenna_wideview_disp"
                        window[curr_ant+"_ant_marker"].name = "Antenna " + curr_ant
                        if (antenna != "none"){
                            window[curr_ant+"_ant_marker"].visible = false
                        }
                        scene.add(window[curr_ant+"_ant_marker"])

                        if (!drawnAntennasList.includes(curr_ant+"_ant_marker")){
                            drawnAntennasList.push(curr_ant+"_ant_marker")
                        }

                    }
                }
            }


            //this function makes sure to hide antenna crosshairs on the sky
            //and show if not in antenna view
            function antennaCrosshairsVisiblity(){
                if (antenna != "none"){
                    for (var i = 0; i < drawnAntennasList.length; i++){
                        //if (window[drawnAntennasList[i]+"_ant_marker"].visible == true){
                        window[drawnAntennasList[i]].visible = false
                        //}
                    }
                }
                if (antenna == "none"){
                    for (var i = 0; i < drawnAntennasList.length; i++){
                        //if (window[drawnAntennasList[i]+"_ant_marker"].visible == false){
                        //window[drawnAntennasList[i]].visible = true
                        //}
                    }
                }
            }


            

            //this function helps with updating the alt-az in the currently selected menu
			function updatetopright(obj){
				var width = window.innerWidth, height = window.innerHeight;
				var widthHalf = width / 2, heightHalf = height / 2;

				var vector = new THREE.Vector3();
				var projector = new THREE.Projector();
				projector.projectVector( vector.setFromMatrixPosition( obj.matrixWorld ), camera );

				object_el = Math.asin(Math.sqrt(vector.x * vector.x + vector.y * vector.y))
				object_el = 90 - (object_el * 180 / Math.PI)

				if (obj.visible != true){
					object_el *= -1;
				}

				//object_az = Math.PI/2 - Math.acos(vector.x / Math.sqrt(vector.x * vector.x + vector.y * vector.y))
				object_az = Math.PI/2 - Math.atan2(vector.y, vector.x)
				object_az = object_az * 180 / Math.PI
				if (object_az < 0){
					object_az = object_az + 360
				}
				
				toprightname = document.getElementById("currentobject").innerHTML
				toprightname = toprightname.split("<br>Alt")[0]

				toprightname += "<br>Alt " + object_el.toFixed(4) + ", Az: " + object_az.toFixed(4)
				/*centerobj.matrixWorldInverse.getInverse( centerobj.matrixWorld );
				vec = new THREE.Vector3(obj.position.x, obj.position.y, obj.position.z)
				vec.applyMatrix4( centerobj.matrixWorldInverse );
				toprightname += "<br>X " + vec.x + " Y: " + vec.y*/

			    document.getElementById("currentobject").innerHTML = toprightname

			}

            var camx, camy, camz;
            var backmask = '';
            var pointing_crosshair = '';
            var antenna_fov_line = '';
            var viewrad = r;
            var view_center_x = 0;
            var view_center_y = 0;
            var camyoffset = 0;
            namedObjectList = [];

            //do the initial ra calculation so interactive mode will start correctly
            ra = calculateSiderealTime(true);
            /*ra = ra.split(":");

            final_ra = ra[0] * 1;
            final_ra += ra[1] / 60;
            final_ra += ra[2] / 3600;
            final_ra = final_ra * 15;
            final_ra = final_ra * Math.PI / 180;
            ra = final_ra;// - Math.PI/2;*/
            ra += raoffset;


            function animate(){
              
                for (var i = 0; i < camera.children.length; i++){
                if (camera.children[i].group == "altaz"){
                  if (antenna != "none"){
                    camera.children[i].visible = false
                  }
                  else{
                    gridCheckboxes()
                  }
                }
                }

                pointing_crosshair.visible = false;
                antenna_fov_line.visible = false;
                //camera.remove(antenna_crosshair_text);
                document.getElementById("crosshairtext").innerHTML = ''
                document.getElementById("crosshair_direction_text").innerHTML = ''
                document.getElementById("crosshair_fov_text").innerHTML = ''

                if (antenna != "none"){
                    camera.zoom = 75
                    pointing_crosshair.visible = true;
                    antenna_fov_line.visible = true;
                    document.getElementById("crosshairtext").innerHTML = "Az "+String(Math.round(pointing_az * 100) /100)+"&#176, El "+String(Math.round(act_alt * 100) / 100)+"&#176"
                    document.getElementById("crosshair_direction_text").innerHTML = 'N'
                    document.getElementById("crosshair_fov_text").innerHTML = String(Math.round(100 * 180/camera.zoom)/ 200)+"&#176" //divide by 200 here instead of 100 to get the radius rather than the diameter
                }

                //get the "Actual" altitude for calculation purposes
                act_alt = pointing_alt

                //get the "actual" azimuth for calculation purposes
                disp_az = pointing_az//(360 - pointing_az) + 90

                if (antenna == "none" && GetURLParameter("controls") == "false"){
                    camera.zoom = 1
                }

                viewrad = r * Math.sin(fov * Math.PI / 180);

                //alt_rectangular = r * Math.cos(pointing_alt * Math.PI / 180);

                antenna_dec = Math.asin( Math.sin(act_alt * Math.PI / 180) * Math.sin(dec) + Math.cos(act_alt * Math.PI / 180) * Math.cos(dec) * Math.cos(disp_az * Math.PI / 180))

                var H = Math.asin( -Math.sin(disp_az * Math.PI / 180) * Math.cos(act_alt * Math.PI / 180) / Math.cos(antenna_dec) )

                if ((disp_az > 270 || disp_az < 90) && antenna != "none"){
                    H = H + (Math.PI/2 - H)*2
                }

                view_center_x = 0//alt_rectangular * Math.cos(pointing_az * Math.PI / 180);
                view_center_y = 0//alt_rectangular * Math.sin(pointing_az * Math.PI / 180);

                camera.updateProjectionMatrix();

                camera.remove(mask);
                mask_geo = new THREE.TorusGeometry(viewrad+5, 5, 2, 100);
                mask_mat = new THREE.MeshBasicMaterial({color:0x000000});
                mask = new THREE.Mesh(mask_geo, mask_mat);
                camera.add(mask);
                mask.position.set(view_center_x, view_center_y, -1);

                ra = calculateSiderealTime(true);
                ra += raoffset;

                antenna_ra = ra - H

                camx = r * Math.cos(ra) * Math.cos(dec);
                camy = r * Math.sin(dec);
                camz = r * Math.sin(ra) * Math.cos(dec);

               for (var i = 1; i < scene.children.length; i++){
                  if (scene.children[i].group == "equatorial" || scene.children[i].spec == "crosshair" || scene.children[i].group == "antenna_wideview_disp"){
                      continue
                  }
                  x = scene.children[i].position.x
                  y = scene.children[i].position.y
                  z = scene.children[i].position.z
                  d = Math.sqrt((camx-x)*(camx-x) + (camy-y)*(camy-y))
                  d = Math.sqrt(d*d + (camz-z)*(camz-z))
                  if (scene.children[i].hid_override != true || scene.children[i].hid_override == undefined){
                      if (d > 10*Math.sqrt(2)){
                          scene.children[i].visible = false;
                      }
                      else{
                          scene.children[i].visible = true;
                      }
                  }

              }             
              requestAnimationFrame(animate);
              if (GetURLParameter("controls") == "true"){
                  controls.target = new THREE.Vector3(camx/100, camy/100, camz/100);
                  controls.update();
              }

              if (GetURLParameter("controls") == "false"){
                ra = antenna_ra

                camx = r * Math.cos(ra) * Math.cos(antenna_dec);
                camy = r * Math.sin(antenna_dec);
                camz = r * Math.sin(ra) * Math.cos(antenna_dec);
                //camyoffset += 0.01
                //camy += camyoffset

                camera.lookAt(camx, camy, camz);
              }

              renderer.render(scene, camera);

            };

            var r = 10;
            var inc = 0
            var scene;
            var camera;
            var renderer;
            pixelratio = 1.5;
            var rmod = 0;

            startScene();
            drawAltAz(0, 0, 0);
            camera.position.set(0, 0, 0);
            camera.zoom = 1;

            var controls = new THREE.TrackballControls(camera, renderer.domElement);
            if (GetURLParameter("controls") == "true"){
              controls.enablePan = true;
              controls.enableDamping = true;
              controls.enableZoom = true;
              controls.keyPanSpeed = 0.2/camera.zoom;
              controls.rotateSpeed = -1/camera.zoom;
              setInterval(function(){
                  controls.keyPanSpeed = 0.2/camera.zoom;
                  controls.rotateSpeed = -1/camera.zoom;
              }, 100)
              controls.dampingFactor = 0.1;
            }
            else{
              controls.enablePan = false;
              controls.enableDamping = false;
              controls.enableZoom = false;              
            }


            animate();

            var satelliterefreshID;
            drawSatellites();

            document.getElementById("equatorialcheckbox").click()
            document.getElementById("equatorialcheckbox").click()


            renderer.domElement.addEventListener("click", onclick, true);
            var selectedObject;
            var raycaster = new THREE.Raycaster();
            var crosshair = new Object();
            var crosshairinterval;
            raycaster.params.Line.threshold = 0.1;
            raycaster.params.Sprite.threshold = 0;
            var toprightnameUpdateInterval = ''

            function onclick(event, obj='none') {
                raycaster.params.Points.threshold = 0.25/camera.zoom
                raycaster.params.Mesh.threshold = 0.25/camera.zoom
                var display = false;
                var mouse = new THREE.Vector2();
                var rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ( (event.clientX - rect.left) / window.innerHeight ) * (2) - (1);
                mouse.y = - ( (event.clientY - rect.top) / window.innerHeight ) * (2) + (1);
                raycaster.setFromCamera(mouse, camera);
                var intersects = raycaster.intersectObjects(scene.children, true); //array
                if ((intersects.length > 0 && intersects[0].object.group != "altaz" && intersects[0].object.group != "equatorial") || obj != 'none'){
                	if (obj == 'none'){
	                    selectedObject = intersects[0]
	                    i = 0
	                    toprightname = "undefined"
	                    display = true;
	                    while (selectedObject.object.group == "altaz" || selectedObject.object.group == "equatorial" || selectedObject.object.name == "textlabel" || selectedObject.object.visible == false){
	                        i += 1;
	                        if (i > intersects.length-1){
	                            display = false;
	                            break
	                        }
	                        selectedObject = intersects[i]
	                    }
	                }
	                else{
	                	selectedObject = new Object()
	                	selectedObject.object = window[obj]
	                	display = true
	                }

                    if (display != false && (selectedObject.object.visible == true || obj != "none")){
                        toprightname = selectedObject.object.name;
                        if (selectedObject.object.group == "NVSS Catalog"){ //"calculate" the name for NVSS objects
                          toprightname = toprightname + "<br>"
                          toprightname = toprightname + "Flux Density: " + selectedObject.object.lum + " mJy"

                        }

                        document.getElementById("currentobject").innerHTML = toprightname

                        //get alt and az coordinates of the object
                        //width and height are both "height" since the drawing space is a square
                        //with side length window.innerHeight
						var width = window.innerWidth, height = window.innerHeight;
						var widthHalf = width / 2, heightHalf = height / 2;

						var vector = new THREE.Vector3();
						var projector = new THREE.Projector();
						projector.projectVector( vector.setFromMatrixPosition( selectedObject.object.matrixWorld ), camera );

						//vector.x = ( vector.x * widthHalf ) + widthHalf;
						//vector.y = - ( vector.y * heightHalf ) + heightHalf;

						clearInterval(toprightnameUpdateInterval)
						updatetopright(selectedObject.object)
						toprightnameUpdateInterval = setInterval(function(){updatetopright(selectedObject.object)}, 100)
                        // crosshair size

                        scene.remove(crosshair)
                        x = 0.25/camera.zoom;
                        y = 0.25/camera.zoom;

                        // crosshair
                        var material = new THREE.LineBasicMaterial({ color: 0xAAFFAA });

                        upbar = new THREE.Geometry();
                        upbar.vertices.push(new THREE.Vector3(0, y*1.2, 0));
                        upbar.vertices.push(new THREE.Vector3(0, y/3, 0));
                        upbar = new THREE.Line( upbar, material )

                        downbar = new THREE.Geometry();
                        downbar.vertices.push(new THREE.Vector3(0, -y/3, 0))
                        downbar.vertices.push(new THREE.Vector3(0, -y*1.2, 0));
                        downbar = new THREE.Line( downbar, material )

                        leftbar = new THREE.Geometry();
                        leftbar.vertices.push(new THREE.Vector3(x*1.2, 0, 0));
                        leftbar.vertices.push(new THREE.Vector3(x/3, 0, 0));
                        leftbar = new THREE.Line( leftbar, material )

                        rightbar = new THREE.Geometry();
                        rightbar.vertices.push(new THREE.Vector3(-x/3, 0, 0))
                        rightbar.vertices.push(new THREE.Vector3(-x*1.2, 0, 0));
                        rightbar = new THREE.Line( rightbar, material )
                        

                        var curve = new THREE.EllipseCurve(
                            0,  0,            // ax, aY
                            x, y,           // xRadius, yRadius
                            0,  2 * Math.PI,  // aStartAngle, aEndAngle
                            false,            // aClockwise
                            0                 // aRotation
                        );

                        var points = curve.getPoints( 50 );
                        var geometry = new THREE.BufferGeometry().setFromPoints( points );

                        crosshair = new THREE.Line( geometry, material );
                        crosshair.add(upbar)
                        crosshair.add(downbar)
                        crosshair.add(leftbar)
                        crosshair.add(rightbar)

                        clearInterval(crosshairinterval)
                        crosshair.position.copy(selectedObject.object.position)
                        if (selectedObject.object.group == "Satellite"){
                            crosshairinterval = setInterval(function(){crosshair.position.copy(selectedObject.object.position)}, 100)
                        }
                        crosshair.hid_override = false;
                        //crosshair.quaternion.copy(camera.quaternion)
                        //keep crosshair pointing to camera
                        crosshair.name = "textlabel"
                        crosshair.spec = "crosshair"
                        scenetextobjects.push(crosshair);
                        scene.add(crosshair)
                    }
                }
            }

            //**********************************************************************************//
            //THESE FUNCTIONS DEAL WITH USER CLICKS AND OBJECT-SPECIFIC DETAILS

            //here is the function for dealing with object searching
            var star_added_code = "&#9745;"
            var star_not_added_code = "&#9744;"
            function dealWithSearchBar(event){
              if (event.keyCode == 13 || event.which == 13){
                searchbar = document.getElementById("objectsearchbar")
                object_list_div = document.getElementById("objectsearch");
                object_matches = namedObjectList.filter(element => element.includes(searchbar.value));
                if (searchbar.value == ''){
                  object_list_div.innerHTML = ''
                  object_list_div.style.background = 'none'
                  document.getElementById("objectmatchestitle").innerHTML = ''
                  return
                }

                object_list_div.style.background = '#222'

                document.getElementById("objectmatchestitle").innerHTML = 'Matches:'
                object_list_div.innerHTML = ''
                //object_list_div.innerHTML += "<div style='position: sticky; width: 100%; height: 25%; top: 0; padding-left: 0 !important; padding-right: 0 !important; padding-top: -20% !important; padding-bottom: 0 !important; background-color: #000; z-index: 10; margin-left: -5%;'>Matches:</div>"
                
                for (i = 0; i < object_matches.length; i++){
                  if (importantObjectList.includes(object_matches[i])){
                    var star = star_added_code + " "
                  }
                  else{
                    var star = star_not_added_code + " "
                  }
                  object_list_div.innerHTML += "<a id='" + object_matches[i] + "_star' href=\"javascript:importantObjectMod('" + object_matches[i] + "')\" style='text-decoration: none; font-size: 20px; color: #67F'>" + star + " </a>"
                  object_list_div.innerHTML += "<a href=\"javascript:searchBarCrosshairMod('" + object_matches[i] + "');\" style='color: #67F'>" + object_matches[i] + "</a>" + "<br>"
                  if (i >= 14){
                    break
                  }
                }
              }
            }

            //function to select object based on crosshair
            function searchBarCrosshairMod(obj){
				var width = window.innerWidth, height = window.innerHeight;
				var widthHalf = width / 2, heightHalf = height / 2;

				var vector = new THREE.Vector3();
				var projector = new THREE.Projector();

				projector.projectVector( vector.setFromMatrixPosition( window[obj].matrixWorld ), camera );
				vector.x = ( vector.x * widthHalf / 2) + widthHalf - 4;
				vector.y = - ( vector.y * heightHalf ) + heightHalf - 4;

				//document.getElementById("testdiv").style.left = vector.x
				//document.getElementById("testdiv").style.top = vector.y
				//document.getElementById("testdiv").innerHTML = "hello there"

				var ev = new Object();

				ev.clientX = vector.x 
				ev.clientY = vector.y

				onclick(ev, obj);

				//document.getElementById("currentobject").innerHTML = obj
            }

            //function to add to Important Objects
            function importantObjectMod(obj){
              if (importantObjectList.includes(obj)){
                scene.remove(window[obj+"_text"])
                scene.remove(window[obj])
                importantObjectList = importantObjectList.filter(item => item !== obj)
                document.getElementById(obj+"_star").innerHTML = star_not_added_code + " "
              }
              else{
              	if (window[obj].group == "Satellite" || window[obj].group == "Satellites"){
              		return
              	}
                drawObjects([window[obj].theta], [window[obj].phi], 0x00fff8, obj, group="Important Objects", false, false, 7, true, false, true)
                rect = thetaPhiToXYZ(window[obj].theta, window[obj].phi)
                addText(obj, [rect[0], rect[1] + 0.001, rect[2]], "Important Objects", false, 0.2);
                importantObjectList.push(obj)
                document.getElementById(obj+"_star").innerHTML = star_added_code + " "
              }
            }

            //**********************************************************************************//
            logged_in = false;

            //function to trigger login panel
            function triggerLogInPanel(){
                if (logged_in){
                    document.getElementById("userpanel").style.display = "block"
                }
                else{
                    document.getElementById("loginpanel").style.display = "block"
                }
                document.getElementById("bgblur").style.display = "block"
            }

            function hideLoginPanel(){
                document.getElementById("loginpanel").style.display = "none"
                document.getElementById("bgblur").style.display = "none"
            }

            function hideUserPanel(){
                document.getElementById("userpanel").style.display = "none"
                document.getElementById("bgblur").style.display = "none"
            }

            function resetFileUpload(form){
                form.submit()
                document.getElementById("catalogFileUpload").value = ""
            }

            function populateUserObjects(user="undef", pass="undef"){
                if (user == "undef" || pass == "undef"){
                    user = document.getElementById("uploadFileUser").value
                    pass = document.getElementById("uploadFilePass").value
                }
                var objects_req = new XMLHttpRequest
                objects_req.open("GET", "/getuserfiles?userid="+user+"&password="+pass)
                objects_req.send()
                objects_req.onreadystatechange = function(){
                    if (this.readyState == 4 && this.status == 200){
                        var user_objects = this.responseText
                        user_objects = user_objects.split(",")
                        document.getElementById("userObjectsDiv").innerHTML = ''
                        if (user_objects[0] == ''){
                            return
                        }
                        for (var i = 0; i < user_objects.length; i++){
                            var name = user_objects[i].split(".csv")[0]
                            document.getElementById("userObjectsDiv").innerHTML += "<input type='checkbox' name='udef_" + name + "' value='true' id='udef_" + name + "' onclick=\"javascript:handleUserCatalog('" + name + "')\" checked><label for='udef_" + name + "' style='color: #EEE; display:inline'> " + name + " </label><br><br>"
                            fetchFileData(user, pass, name)
                        }
                    }
                }
            }

            function fetchFileData(user, pass, file){
                var file_req = new XMLHttpRequest;
                file_req.open("GET", "/getfiledata?userid=" + user + "&password=" + pass + "&file=" + file)
                file_req.send();
                file_req.onreadystatechange = function(){
                    if (this.readyState == 4 && this.status == 200){
                        var file_data = this.responseText
                        var file_ras = file_data.split("$")[1].split(",")
                        var file_decs = file_data.split("$")[2].split(",")
                        var file_names = file_data.split("$")[0].split(",")
                        console.log(file)
                        console.log(file_ras)
                        window["udef_"+file+"_list"] = []
                        drawObjects(file_ras, file_decs, 0xeeeeee, file_names, "udef_"+file, true);
                    }
                }
            }

            function handleUserCatalog(file){
                var box = document.getElementById("udef_"+file)
                if (box.checked){
                    for (var i = 0; i < window["udef_"+file+"_list"].length; i++){
                        window["udef_"+file+"_list"][i].visible = true
                        window["udef_"+file+"_list"][i].hid_override = false
                    }
                }
                else{
                    for (var i = 0; i < window["udef_"+file+"_list"].length; i++){
                        window["udef_"+file+"_list"][i].visible = false
                        window["udef_"+file+"_list"][i].hid_override = true
                    }
                }
            }

            //function to send login request to server
            function sendLoginRequest(event, create=false){
                if (event.keyCode == 13 || event.which == 13){
                    if (create){
                        mode = "create"
                    }
                    else{
                        mode = "login"
                    }
                    var userid = document.getElementById(mode+"_user").value
                    var pass = document.getElementById(mode+"_pass").value
                    var create_req = new XMLHttpRequest();
                    if (create){
                        create_req.open("GET", "/createuser?userid=" + userid + "&password=" + pass);
                    }
                    else{
                        create_req.open("GET", "/login?userid=" + userid + "&password=" + pass);
                    }
                    create_req.send()
                    create_req.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            result = this.responseText;
                            if (result == "Success"){
                                logged_in = true;
                                //update the user panel with information and such
                                document.getElementById("userid_button").value = userid
                                document.getElementById("loginpanel").style.display = "none"
                                document.getElementById("userpanel").style.display = "block"
                                document.getElementById("uploadFileUser").value = userid
                                document.getElementById("uploadFilePass").value = pass
                                populateUserObjects(userid, pass)
                            }
                            else{
                                document.getElementById(mode+"Result").innerHTML = result;
                            }
                        }
                    };
                    
                }                
            }



            //intialize the antenna view crosshair
            mat = new THREE.LineBasicMaterial( {color: 0xff0000} )
            geo = new THREE.Geometry();
            size = 0.01
            geo.vertices.push(new THREE.Vector3(size, 0, 0));
            geo.vertices.push(new THREE.Vector3(-size, 0, 0));
            geo.vertices.push(new THREE.Vector3(0, 0, 0));
            geo.vertices.push(new THREE.Vector3(0, -size, 0));
            geo.vertices.push(new THREE.Vector3(0, size, 0));
            pointing_crosshair = new THREE.Line(geo, mat);
            pointing_crosshair.position.set(0, 0, -1)
            camera.add(pointing_crosshair)
            pointing_crosshair.visible = false;

            //initialize the fov line for the antenna view
            mat = new THREE.LineBasicMaterial( {color: 0xff0000} )
            geo = new THREE.Geometry();
            var outer_rad_antenna = r / 75;
            min = 0.1 * outer_rad_antenna
            max = 0.9 * outer_rad_antenna
            var start = min * Math.cos(Math.PI / 4)
            var end = max * Math.cos(Math.PI / 4)
            geo.vertices.push(new THREE.Vector3(-start, start, 0))
            geo.vertices.push(new THREE.Vector3(-end, end, 0))
            geo.vertices.push(new THREE.Vector3(-end - 0.03 * outer_rad_antenna, end - 0.03*outer_rad_antenna, 0))
            geo.vertices.push(new THREE.Vector3(-end + 0.03 * outer_rad_antenna, end + 0.03*outer_rad_antenna, 0))
            antenna_fov_line = new THREE.Line(geo, mat)
            antenna_fov_line.position.set(0, 0, -1)
            camera.add(antenna_fov_line)
            antenna_fov_line.visible = false;

            drawObjects(atnf_thetas, atnf_phis, 0xff0000, atnf_names, "ATNF Catalog", true);
            drawObjects(nvss_thetas, nvss_phis, 0x9400d3, '', "NVSS Catalog", false);
            drawObjects(frb_thetas, frb_phis, 0x00ff00, frb_names, "FRB Catalog", true);
            drawObjects(messier_thetas, messier_phis, 0x00aaff, messier_names, "Messier Catalog", true);
            drawObjects(rrat_thetas, rrat_phis, 0xffff00, rrat_names, "RRAT Catalog", true);
            addObjectLabels();
            dealWithCheckboxes();

            tempevent = new Object();
            tempevent.clientX = window.innerWidth / 2
            tempevent.clientY = window.innerHeight / 2
            crosshair.hid_override = true;

            setInterval(redoLabels, 10);

            //initialize crosshair object
			x = 0.25/camera.zoom;
			y = 0.25/camera.zoom;
			var material = new THREE.LineBasicMaterial({ color: 0xAAFFAA });

	        upbar = new THREE.Geometry();
	        upbar.vertices.push(new THREE.Vector3(0, y*1.2, 0));
	        upbar.vertices.push(new THREE.Vector3(0, y/3, 0));
	        upbar = new THREE.Line( upbar, material )

	        downbar = new THREE.Geometry();
	        downbar.vertices.push(new THREE.Vector3(0, -y/3, 0))
	        downbar.vertices.push(new THREE.Vector3(0, -y*1.2, 0));
	        downbar = new THREE.Line( downbar, material )

	        leftbar = new THREE.Geometry();
	        leftbar.vertices.push(new THREE.Vector3(x*1.2, 0, 0));
	        leftbar.vertices.push(new THREE.Vector3(x/3, 0, 0));
	        leftbar = new THREE.Line( leftbar, material )

	        rightbar = new THREE.Geometry();
	        rightbar.vertices.push(new THREE.Vector3(-x/3, 0, 0))
	        rightbar.vertices.push(new THREE.Vector3(-x*1.2, 0, 0));
	        rightbar = new THREE.Line( rightbar, material )
	        

	        var curve = new THREE.EllipseCurve(
	            0,  0,            // ax, aY
	            x, y,           // xRadius, yRadius
	            0,  2 * Math.PI,  // aStartAngle, aEndAngle
	            false,            // aClockwise
	            0                 // aRotation
	        );

	        var points = curve.getPoints( 50 );
	        var geometry = new THREE.BufferGeometry().setFromPoints( points );

	        crosshair = new THREE.Line( geometry, material );
	        crosshair.add(upbar)
	        crosshair.add(downbar)
	        crosshair.add(leftbar)
	        crosshair.add(rightbar)

            crosshair.name = "textlabel"
            crosshair.spec = "crosshair"
            scenetextobjects.push(crosshair);
	        crosshair.visible = false;
	        scene.add(crosshair)

	        centerobj_geo = new THREE.Geometry()
            centerobj_mat = new THREE.PointsMaterial({ size: 2, sizeAttenuation: false, color: 0x000000 })
            centerobj = new THREE.Points(centerobj_geo, centerobj_mat)
            scene.add(centerobj)

            drawSun()
            //redraw sun every hour...
            setInterval(drawSun, 3600000);

            drawMoon()
            //redraw moon ever half hour...
            setInterval(drawMoon, 1800000);


            setInterval(updateAntennaCrosshairs, 500);


        </script>
        </gui>
    </body>
</html>
