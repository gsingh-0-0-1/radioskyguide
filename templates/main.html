<html>
    <head>

        <title>Radio SkyGUIde</title>
        <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
        <style>
            body { margin: 0; text-align: center; background-color: #000000}
            canvas { display: block; }
            gui {position: fixed; left:50%; top:0px; transform: translate(-50%, -0%);}
            .sidtime {position: fixed; left:5%; top:15%; font-family:Verdana; text-align: center;}
            .leftdetails {position: fixed; left:5%; top:5%; font-family:Verdana; text-align: center; transform: translate(-5%,0%); overflow-y: scroll; height: 95% }
            .rightdetails {position: fixed; left:80%; top:5%; font-family:Verdana; text-align: center; transform: translate(-5%,0%); overflow-y: scroll; height: 95%; width: 20%;}
            .button {
              background-color: var(--bcolor);
              border: none;
              color: white;
              padding: 15px 24px;
              text-align: center;
              text-decoration: none;
              display: inline-block;
              font-size: var(--fsize);
              margin: 4px 2px;
              cursor: pointer;
            }
/*Checkboxes styles*/
input[type="checkbox"] { display: none; }

input[type="checkbox"] + label {
  display: block;
  position: relative;
  padding-left: 35px;
  margin-bottom: 20px;
  color: #ddd;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

input[type="checkbox"] + label:last-child { margin-bottom: 0; }

input[type="checkbox"] + label:before {
  content: '';
  display: block;
  width: 20px;
  height: 20px;
  border: 1px solid #6cc0e5;
  position: absolute;
  left: 0;
  top: 0;
  opacity: .6;
  -webkit-transition: all .12s, border-color .08s;
  transition: all .12s, border-color .08s;
}

input[type="checkbox"]:checked + label:before {
  width: 10px;
  top: -5px;
  left: 5px;
  border-radius: 0;
  opacity: 1;
  border-top-color: transparent;
  border-left-color: transparent;
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
}
/* width */
::-webkit-scrollbar {
  width: 10px;
}

/* Track */
::-webkit-scrollbar-track {
  background: #222;
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: #456789;
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: #345678;
}



.slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 80%; /* Full-width */
  height: 25px; /* Specified height */
  background: #123456; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #9400d3; /* Green background */
  cursor: pointer; /* Cursor on hover */
}


select {
  width: 50%;
  height: 40px;
  font-size: 15px;
  cursor: pointer;
  border-radius: 0;
  background-color: #5511a0;
  border: none;
  border-bottom: 2px solid #220088;
  color: white;
  padding: 10px;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 10px;
}

select:focus{
  outline: none;
}

swal.fire({
  icon: 'warning',
  title: 'Quick Note',
  text: 'Interactive mode is in development, and might be a little buggy. It is also not compatible with the antennae view - please switch back to non-interactive to use those. Rendering satellites with interactive mode might also be a little laggy.',
  footer: 'Radio SkyGUIde'
})
        </style>
        <script language="javascript" type="text/javascript" src="/static/astro.js"></script>
        <script language="javascript" type="text/javascript" src="/static/astro.ephem.js"></script>
        <script language="javascript" type="text/javascript" src="https://threejs.org/build/three.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>
        <script language="javascript" type="text/javascript" src="/static/examples/js/controls/TrackballControls.js"></script>
        <script src="/static/examples/js/controls/TrackballControls.js"></script>
        <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    </head>
    <body onload="fullReload();">
        <div id="leftdetails" class="leftdetails">
            <input type="button" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Approximate LST at the {{ abbr_here }}"><br>
            <span id="sidtime">
            </span>
            <br><br><br>

            <span id="antennae">
            <input type="button" class="button" style="--bcolor: #3f1166; --fsize: 15px;" value="Available Antennae">
            <br>
            <select id="antenna_select" onchange="javascript:changeAntenna();">
              <option value="none">None</option>
            </select>
            </span>

            <br>
            <div>

                <br>
                <table style="text-align: center; display:inline;">
                <tr>
                <td>
                <input type="button" class="button" style="--bcolor: #749fd8; --fsize: 15px; font-family: courier" value="+5m" onclick="offsetRA(1.25);">
                </td>
                <td>
                <input type="button" class="button" style="--bcolor: #cb8080; --fsize: 15px; font-family: courier" value="-5m" onclick="offsetRA(-1.25);">
                </td>
                </tr>
                
                <tr>
                <td>
                <input type="button" class="button" style="--bcolor: #356fbb; --fsize: 15px; font-family: courier" value="+1h" onclick="offsetRA(15);">
                </td>
                <td>
                <input type="button" class="button" style="--bcolor: #b54a4a; --fsize: 15px; font-family: courier" value="-1h" onclick="offsetRA(-15);">
                </td>
                </table>

                <br>
                <input type="text" class="button" id="delaybox" style="--bcolor: #553555; --fsize: 15px;" placeholder="Custom Time Offset" onkeypress="javascript:customRaOffset(event);">
                <br>
                <input type="text" class="button" id="cont_del_box" style="--bcolor: #553555; --fsize: 15px;" placeholder="Animate (Min/Sec)" onkeypress="javascript:delayAnimate(event)">

                <br>
                <input type="button" class="button" style="--bcolor: #553555; --fsize: 15px;" value="Reset and Re-center" onclick="offsetRA(0, true); controls.reset()">
                <br>
                <div id="totaloffset">
                    <input type="button" class="button" style="--bcolor: #444444; --fsize: 15px;" value="Total Time Offset (min): 0">
                </div>
            </div>
            <br>
        </div>

        <div id="crosshairtext" style="position:absolute; display:inline-block; top:45%; left:52%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>
        <div id="crosshair_fov_text" style="position:absolute; display:inline-block; top:30%; left:43%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>
        <div id="crosshair_direction_text" style="position:absolute; display:inline-block; top:2%; left:50%; font-family:Verdana; z-index: 5; color: #FF0000">
        </div>

        <div id='rightdetails' class='rightdetails'>
            <div id="currentlyshowing" style="display: inline; color: #56789a">Currently Selected<br><br>
                <div id="currentobject">None</div>
            </div>
            <br><br>
            <!--<input type="button" class="button" style="--bcolor: #123456; --fsize: 15px;" value="-Select Objects to Draw-"><br><br>-->
            <div style="text-align: left">
            <form>

                <input type="checkbox" name="drawatnf" value="true" id="drawatnf" onclick="dealWithCheckboxes();" checked>
                <label for="drawatnf" style="color: #FF0000; display:inline">ATNF Catalog</label><br><br>

                <input type="checkbox" name="drawfrb" value="true" id="drawfrb" onclick="dealWithCheckboxes();">
                <label for='drawfrb' style="color: #00FF00; display:inline">FRB Catalog</label><br><br>

                <input type="checkbox" name="drawrrat" value="true" id="drawrrat" onclick="dealWithCheckboxes();">
                <label for='drawrrat' style="color: #FFFF00; display:inline">RRATalog</label><br><br>

                <input type="checkbox" name="drawnvss" value="true" id="drawnvss" onclick="nvssDialogue();">
                <label id='fornvss' for='drawnvss' style="color: #9400d3; display:inline">NVSS Catalog (>0.2 Jy)</label><br><br>

                <input type="range" min="0.2" max="5" value="0" class="slider" id="nvss_slider" step="0.0001" onchange="dealWithNVSSSlider();"><br><br>

                <input type="checkbox" name="drawmessier" value="true" id="drawmessier" onclick="dealWithCheckboxes();">
                <label for='drawmessier' style="color: #00AAFF; display:inline">Messier Catalog</label><br><br>

                <input type="checkbox" name="drawsatellites" value="true" id="drawsatellites" onclick="dealWithCheckboxes();">
                <label for='drawsatellites' style="color: #FFFFFF; display:inline">Starlink Satellites</label><br><br>

                <input type="checkbox" name="drawimportant" value="true" id="drawimportant" onclick="dealWithCheckboxes();" checked>
                <label for='drawimportant' style="color: #00FFF8; display:inline">Important Objects</label><br><br>
            </form>
            
            <form>
                <input type="checkbox" name="equatorialcheckbox" value="true" id="equatorialcheckbox" onclick="gridCheckboxes();">
                <label for="equatorialcheckbox" style="color: #999999; display:inline">Equatorial Grid</label>
                <br><br>
                <input type="checkbox" name="altazcheckbox" value="true" id="altazcheckbox" onclick="gridCheckboxes();" checked>
                <label for="altazcheckbox" style="color: #999999; display:inline">Alt-Az Grid</label>
            </form>
            </div>
            <br><br>
            <form action='/main'>
                <input type="hidden" name="alt" value="90">
                <input type="hidden" name="az" value="0">
                <input type="hidden" name="fov" value="90">
                <input type="hidden" name="antenna" value="none">
                <input type="hidden" name="loc" value="{{ loc_here }}">
                <input type="hidden" name="longitude" value="{{ longitude_here }}">
                <input type="hidden" name="latitude" value="{{ declination_here }}">
                <input type="hidden" name="controls" id="controls" value="tobefilled">
                <input type="Submit" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Toggle Interactive Mode">
            </form>
            <br>
            <form action='/'>
                <input type="Submit" class="button" style="--bcolor: #123456; --fsize: 15px;" value="Restart">
            </form>
            <div id="modifyaltaz">
                <!--<input id="alt_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="Altitude (&#176)" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="alt_box" type="hidden">
                <br>

                <!--<input id="az_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="Azimuth: North = 0&#176" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="az_box" type="hidden">
                <br>

                <!--<input id="fov_box" class="button" style="--bcolor: #123456; --fsize: 15px;" placeholder="FOV (&#176)" onkeypress="javascript:dealWithAltAzInput(event);">-->
                <input id="fov_box" type="hidden">
                <br>
            </div>
            <br>

        </div>
        <gui id='gui'>
        <script>
            astrojs.ready(function(e){

            });

            //deal with the controls on/off situation
            c = document.getElementById("controls");
            if (GetURLParameter("controls") == "true"){
                c.value = "false"
            }
            else{
                c.value = "true"
            }

            if (GetURLParameter("loc") != "Allen+Telescope+Array" || GetURLParameter("controls") == "true"){
                document.getElementById("antennae").innerHTML = ''
            }

            if (GetURLParameter("controls") == "true"){
                swal("Interactive Mode Note", "Interactive mode is still being worked on, and might be a little buggy. It's also not easily compatible with the antenna view - please revert back to non-interactive before using the antennae buttons.", "warning")
            }

            var continuousDelayAnimateInterval;

            function delayAnimate(event){
                if (event.keyCode == 13 || event.which == 13){
                    clearInterval(continuousDelayAnimateInterval);
                    if (document.getElementById("cont_del_box").value*1 != 0){
                        val = document.getElementById("cont_del_box").value;
                        continuousDelayAnimateInterval = setInterval(function(){
                            offsetRA(val/40, 100)
                        }, 100)
                    }
                }
            }

            function GetURLParameter(sParam){

                var sPageURL = window.location.search.substring(1);
                var sURLVariables = sPageURL.split('&');

                for (var i = 0; i < sURLVariables.length; i++){

                    var sParameterName = sURLVariables[i].split('=');
                    if (sParameterName[0] == sParam) {
                        return sParameterName[1];
                    }
                }
            }

            function dealWithAltAzInput(event){
                if (event.keyCode == 13 || event.which == 13){
                    alt_box = document.getElementById("alt_box");
                    az_box = document.getElementById("az_box");
                    fov_box = document.getElementById("fov_box");
                    if (alt_box.value == ''){
                        alt_box.value = 90
                    }
                    if (az_box.value ==''){
                        az_box.value = 0
                    }
                    if (fov_box.value ==''){
                        fov_box.value = 90
                    }
                    pointing_alt = alt_box.value;
                    temp_az = parseFloat(az_box.value) * 1;
                    temp_az = 360 - temp_az;
                    pointing_az = temp_az + 90;
                    fov = fov_box.value;
                }
            }


            function customRaOffset(event){
                if (event.keyCode == 13 || event.which == 13){
                    delaybox = document.getElementById("delaybox");
                    offsetRA(delaybox.value/4);
                }
            }

            var loc = "{{ loc_here }}";
            var longitude = {{ longitude_here }};

            var atnfcheckbox = document.getElementById("drawatnf");
            var frbcheckbox = document.getElementById("drawfrb");
            var messiercheckbox = document.getElementById("drawmessier");
            var satellitecheckbox = document.getElementById("drawsatellites");
            var rratcheckbox = document.getElementById("drawrrat");
            var nvsscheckbox = document.getElementById("drawnvss");
            var importantcheckbox = document.getElementById("drawimportant");
            var catboxlist = [atnfcheckbox, frbcheckbox, messiercheckbox, rratcheckbox, nvsscheckbox];
            var catnames = ["ATNF Catalog", "FRB Catalog", "Messier Catalog", "RRAT Catalog", "NVSS Catalog"];
            var catshorthands = ["atnf", "frb", "messier", "rrat", "nvss"]
            var catcolors = [0xff0000, 0x00ff00, 0x00aaff, 0xffff00, 0x9400d3];
            for (var i = 0; i < catboxlist.length; i++){
                window[catnames[i]+"_list"] = [];
            }

            function dealWithCheckboxes(){

                for (var iter = 0; iter < catboxlist.length; iter++){
                    box = catboxlist[iter];
                    if (box.checked){
                        if (window[catnames[iter]+"_list"].length > 0){
                            if (box == nvsscheckbox){
                                dealWithNVSSSlider();
                            }
                            else{
                                for (var j = 0; j < window[catnames[iter]+"_list"].length; j++){
                                    window[catnames[iter]+"_list"][j].visible = true;
                                    window[catnames[iter]+"_list"][j].hid_override = false;
                                }
                            }
                        }
                        else{
                          if (catnames[iter] == "NVSS Catalog"){
                            drawObjects(window[catshorthands[iter]+"_thetas"], window[catshorthands[iter]+"_phis"], catcolors[iter], '', group=catnames[iter], false, false, 7, true, true);
                          }
                          else{
                            drawObjects(window[catshorthands[iter]+"_thetas"], window[catshorthands[iter]+"_phis"], catcolors[iter], '', group=catnames[iter]);
                          }
                        }
                    }
                    else{
                        if (window[catnames[iter]+"_list"].length > 0){
                            for (var j = 0; j < window[catnames[iter]+"_list"].length; j++){
                                window[catnames[iter]+"_list"][j].visible = false;
                                window[catnames[iter]+"_list"][j].hid_override = true;
                            }
                        } 
                    }
                }

                if (satellitecheckbox.checked){
                    updateSatellites();
                    clearInterval(satelliterefreshID);
                    satelliterefreshID = setInterval(updateSatellites, 1000);
                }
                else{
                    clearInterval(satelliterefreshID);
                    satellite_list = []
                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].name == "Satellite" || scene.children[i].group == "Satellite")
                            scene.remove(scene.children[i]);
                    }              
                }

                if (importantcheckbox.checked){
                    obj = 0; 
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "Important Objects"){
                            scene.children[i].visible = true;
                            scene.children[i].hid_override = false;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        addObjectLabels();
                    }
                }
                else{
                    for (let i = scene.children.length - 1; i >= 0; i--){
                        if (scene.children[i].group == "Important Objects"){
                            scene.children[i].visible = false;
                            scene.children[i].hid_override = true;
                        }
                    }             
                }
            }

            function dealWithNVSSSlider(){
                if (nvsscheckbox.checked){
                    min_val = document.getElementById("nvss_slider").value * 1
                    document.getElementById("fornvss").innerHTML = "NVSS Catalog (>" + min_val +" Jy)"
                    for (var i = 0; i < window["NVSS Catalog_list"].length; i++){
                        if (nvss_lum[i] >= min_val*1000){
                            window["NVSS Catalog_list"][i].visible = true;
                            window["NVSS Catalog_list"][i].hid_override = false;
                        }
                        else{
                            window["NVSS Catalog_list"][i].visible = false;
                            window["NVSS Catalog_list"][i].hid_override = true;
                        }
                    }
                }

            }

            function nvssDialogue(){
              if (nvsscheckbox.checked){
                document.getElementById("fornvss").innerHTML = 'Loading Objects...'
              }
              setTimeout(dealWithCheckboxes, 200)
              setTimeout(function(){document.getElementById("fornvss").innerHTML = 'NVSS Catalog (>0.2 Jy)'}, 1000)

            }

            function gridCheckboxes(){
                altazcheckbox = document.getElementById("altazcheckbox");
                equatorialcheckbox = document.getElementById("equatorialcheckbox");

                if (equatorialcheckbox.checked){
                    obj = 0;
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "equatorial"){
                            scene.children[i].visible = true;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        addRALines();
                        writeRALabels();
                        addDecLines();
                        writeDecLabels();
                        //equatorialGrid();
                    }
                }
                else{
                    for (let i = scene.children.length - 1; i >= 0; i--) {
                        if(scene.children[i].group == "equatorial")
                            scene.children[i].visible = false;
                    }    
                }

                if (altazcheckbox.checked){
                    obj = 0;
                    for (let i = camera.children.length - 1; i >= 0; i--) {
                        if(camera.children[i].group == "altaz"){
                            camera.children[i].visible = true;
                            obj += 1;
                        }
                    }
                    if (obj == 0){
                        drawAltAz(0, 0, 0);
                    }
                }
                else{
                    for (let i = camera.children.length - 1; i >= 0; i--){
                        if (camera.children[i].group == "altaz")
                            camera.children[i].visible = false;
                    }                        
                }
            }

            function calculateSiderealTime(raw){

                //get the time in UTC
                seconds_since_j2000 = Math.floor(Date.now()/1000) - 946684800;

                seconds = seconds_since_j2000 % 86400;

                hours = Math.floor(seconds/3600);
                minutes = Math.floor(seconds/60) - hours*60;
                seconds = seconds - minutes*60 - hours*3600;

                days_since_j2000 = seconds_since_j2000 / 86400;

                hours_passed = seconds_since_j2000 % 86400
                hours_passed = hours_passed / 3600

                siderealtime = 100.46;
                siderealtime += (0.985647 * days_since_j2000);
                siderealtime += longitude;

                siderealtime += 15*hours_passed;

                siderealtime = siderealtime % 360;
                siderealtime = siderealtime / 15;

                if (raw==true){
                
                    return siderealtime;
                }

                else{
                    hours = Math.floor(siderealtime);
                    siderealtime = siderealtime - hours;
                    minutes = Math.floor(siderealtime*60);
                    siderealtime = siderealtime - minutes/60;
                    seconds = Math.floor(siderealtime*3600);

                    if (String(hours).length < 2){
                        hours = '0' + hours;
                    }
                    if (String(minutes).length < 2){
                        minutes = '0' + minutes;
                    }
                    if (String(seconds).length < 2){
                        seconds = '0' + seconds;
                    }

                    return hours + ":" + minutes + ":" + seconds;
                }
            }


            function fullReload() {
                sid = document.getElementById("sidtime");
                sid.innerHTML = "<input type='button' class='button' style='--bcolor: #123456; --fsize: 15px;' value=" +calculateSiderealTime(false) + ">";
                setTimeout(fullReload, 500);
            }

            //var drawingSurface = document.getElementByID('gui');

            var r = 10;
            var scene;
            var camera;
            var renderer;
            pixelratio = 1.5;
            var rmod = 0;

            function startScene(){
                var width = window.innerWidth;
                var height = window.innerHeight;
                camera = new THREE.OrthographicCamera( -(r+rmod), (r+rmod), (r+rmod), -(r+rmod), 0, 1000 );
                //camera = new THREE.PerspectiveCamera( 90, 1, 1, 100000 );
                renderer = new THREE.WebGLRenderer({antialias: true});
                //renderer.setPixelRatio( pixelratio, pixelratio );
                renderer.setSize(height, height);
                document.getElementById('gui').appendChild(renderer.domElement);

                scene = new THREE.Scene({canvas:gui});
                scene.background = new THREE.Color( 0x000000 );
                scene.add(camera);
            }

            //draw RA lines

            function addDecLines(visible=true){
                angles = [0, Math.PI/6, -Math.PI/6, Math.PI/4, -Math.PI/4, Math.PI/3, -Math.PI/3, 5*Math.PI/12, -5*Math.PI/12];
                color = 0xffff00
                for (var angle = 0; angle < angles.length; angle++){
                    if (angles[angle] == 0){
                        color = 0xffa500;
                    }
                    else{
                        color = 0xffffff;
                    }
                    ring_rad = r * Math.cos(angles[angle]);
                    ring_width = 0.06
                    //var geometry = new THREE.TorusGeometry(ring_rad, ring_width/2, 16, 48);
                    var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                    //var material = new THREE.MeshBasicMaterial( { color: color } );
                    //line = new THREE.Mesh( geometry, material );
                    var edges = new THREE.EdgesGeometry( geometry );
                    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );
                    line.position.set(0, r*Math.sin(angles[angle]), 0);
                    line.rotation.setFromVector3(new THREE.Vector3(Math.PI/2, 0, Math.PI/2));
                    line.group = "equatorial";
                    //line.material.shading = THREE.SmoothShading;
                    if (visible == false){
                        line.visible = false;
                    }
                    scene.add(line);
                }
            }

            //draw DEC lines

            function addRALines(visible=true){
                color = 0xffffff;
                angles = [0, Math.PI/2];
                for (var angle = 0; angle < angles.length; angle++){
                    ring_rad = r;
                    ring_width = 0.06
                    //var geometry = new THREE.TorusGeometry(ring_rad, ring_width/2, 16, 48);
                    //var material = new THREE.MeshBasicMaterial( { color: color, side: THREE.DoubleSide } );

                    //line = new THREE.Mesh( geometry, material );
                    var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                    var edges = new THREE.EdgesGeometry( geometry );
                    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );
                    
                    line.position.set(0, 0, 0);
                    line.rotation.setFromVector3(new THREE.Vector3(0, angles[angle], angles[angle]));
                    line.group = "equatorial";
                    line.material.shading = THREE.SmoothShading;
                    if (visible==false){
                        line.visible = false;
                    }
                    scene.add(line);
                }
            }

            function equatorialGrid(){
                var radius = r;
                var latSegments = 18;
                var longSegments = 16;

                var geometry = new THREE.SphereBufferGeometry( radius, longSegments, latSegments);
                var edges = new THREE.EdgesGeometry( geometry );
                var sphere = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );

                sphere.group = "equatorial"
                scene.add( sphere );

                var geometry = new THREE.CircleGeometry( 10, 36 );
                var edges = new THREE.EdgesGeometry( geometry );
                var equator = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffa500 } ) );
                equator.lookAt(0, 10, 0);
                equator.group = "equatorial";
                scene.add(equator)
            }

            var scenetextobjects = [];

            function addText(text, pos, group, addtocamera=false, size=0.35, color=0x00fff8){
                var loader = new THREE.FontLoader();
                loader.load( '/static/examples/fonts/helvetiker_bold.typeface.json', function (font){
                    var textGeo = new THREE.TextGeometry( text, {
                        font: font,
                        size: size,
                        height: 0.01,
                        curveSegments: 24,
                        bevelEnabled: false

                    } );
                    var textMaterial = new THREE.MeshBasicMaterial( { color: color } );

                    var mesh = new THREE.Mesh( textGeo, textMaterial );

                    if (addtocamera==true){
                        camera.add(mesh);
                    }
                    else{
                        scene.add(mesh);
                    }
                    mesh.position.set(pos[0], pos[1], pos[2]);
                    mesh.name = "textlabel";
                    mesh.group = group;
                    if (addtocamera==false)
                        scenetextobjects.push(mesh);
                } );
            }


            var frb_thetas = {{ frb_ra_dat_here }};
            var frb_phis = {{ frb_dec_dat_here }}
            var frb_names = {{ frb_name_dat_here | safe}}

            var atnf_thetas = {{ atnf_ra_dat_here }};
            var atnf_phis = {{ atnf_dec_dat_here }};
            var atnf_names = {{ atnf_name_dat_here | safe}}

            var messier_thetas = {{ messier_ra_dat_here }};
            var messier_phis = {{ messier_dec_dat_here }};
            var messier_names = {{ messier_name_dat_here | safe }}

            var rrat_thetas = {{ rrat_ra_dat_here }}
            var rrat_phis = {{ rrat_dec_dat_here }}
            var rrat_names = {{ rrat_name_dat_here | safe }}

            var nvss_thetas = {{ nvss_ra_dat_here }};
            var nvss_phis = {{ nvss_dec_dat_here }}
            var nvss_lum = {{ nvss_lum_dat_here }}
            var nvss_names = {{ nvss_name_dat_here | safe }}

            function createCircleTexture(color, size=400, group) {
                var matCanvas = document.createElement('canvas');
                matCanvas.width = matCanvas.height = size;
                var matContext = matCanvas.getContext('2d');
                // create texture object from canvas.
                var texture = new THREE.Texture(matCanvas);
                // Draw a circle
                var center = size / 2;
                matContext.beginPath();
                matContext.shadowBlur = 100;
                matContext.shadowColor = 'white';
                matContext.arc(center, center, 70, 0, 2 * Math.PI, false);
                matContext.fillStyle = color;
                matContext.fill();

              // need to set needsUpdate
                texture.needsUpdate = true;
              // return a texture made from the canvas
                return texture;
            }

            function drawObjects(thetas, phis, color, name, group='', listofnames=false, satellitemode=false, size=7, visible=true, nvss=false) {
                color = "#" + color.toString(16).padStart(6, '0');
                if (name != "Satellite" && group != "Satellite")
                    thistexture = createCircleTexture(color, 400, group);
                for (var i = 0; i < thetas.length; i++){
                    theta = thetas[i];
                    phi = phis[i];

                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);

                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(new THREE.Vector3(0, 0, 0))
                    if (name == "Satellite" || group == "Satellite")
                        var material = new THREE.PointsMaterial( { size: 2, sizeAttenuation: false, color: color } );
                    else
                        var material = new THREE.PointsMaterial({
                                      size: size,
                                      map: thistexture,
                                      transparent: true,
                                      depthWrite: false
                                    });
                    var point = new THREE.Points( geometry, material );
                    if (listofnames==true){
                        point.name = name[i]
                    }
                    else{
                        point.name = name;
                    }

                    if (nvss){
                      point.lum = nvss_lum[i]
                    }

                    if (group != ''){
                        point.group = group;
                        if (group.includes("Catalog"))
                            window[group+"_list"].push(point)
                    }

                    if (satellitemode == true){
                        point.sat_tag = i;
                        
                        if (listofnames==true){
                            satellite_list.push(name[i]);
                            window[name[i]] = point;
                        }
                        else{
                            satellite_list.push(name);
                            window[name] = point;
                        }
                    }

                    point.theta = theta
                    point.phi = phi
                    point.visible = visible;
                    scene.add(point);

                    point.position.set(x,y,z);
                }
            }



            var dec = {{ declination_here }} * Math.PI / 180;
            var ra = 0;

            //write declination labels
            function writeDecLabels(visible=true){
                labels = [-5*Math.PI/12, -Math.PI/3, -Math.PI/4, -Math.PI/6, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];
                for (var i = 0; i < labels.length; i++){
                    shift = 0.2;
                    mainaxis = r * Math.cos(labels[i]);
                    elev = shift + r * Math.sin(labels[i]);
                    deg_angle = Math.round(labels[i] * 180 / Math.PI)
                    addText(deg_angle+String.fromCharCode("0176"), [mainaxis, elev, shift], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [-shift, elev, mainaxis], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [-mainaxis, elev, -shift], "equatorial");
                    addText(deg_angle+String.fromCharCode("0176"), [shift, elev, -mainaxis], "equatorial");
                }
            }

            //write ra labels
            function writeRALabels(visible=true){
                labels = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                for (var i = 0; i < labels.length; i++){
                    angle = labels[i];
                    hour = angle * 180 / Math.PI;
                    hour = Math.round(hour/15);

                    addText(String(hour)+'h', [r*Math.cos(angle)+0.2, 0.2, r*Math.sin(angle)], "equatorial");
                }
            }

            function drawSun(){
                seconds_since_j2000 = Math.floor(Date.now()/1000) - 946684800;

                seconds = seconds_since_j2000 % 86400;

                hours = Math.floor(seconds/3600);
                minutes = Math.floor(seconds/60) - hours*60;
                seconds = seconds - minutes*60 - hours*3600;

                days_since_j2000 = seconds_since_j2000 / 86400;

                //other calculations 
                L = 280.460 + (0.9856474 * days_since_j2000)
                g = 357.528 + (0.9856003 * days_since_j2000)
                lambda = L + (1.915 * Math.sin(g * Math.PI/180)) + (0.02 * Math.sin(2 * g * Math.PI/180));

                obl_earth = 23.43663;

                ra_sun = Math.atan2(Math.cos(obl_earth*Math.PI/180) * Math.sin(lambda*Math.PI/180), Math.cos(lambda*Math.PI/180));
                dec_sun = Math.asin(Math.sin(obl_earth*Math.PI/180) * Math.sin(lambda*Math.PI/180));

                sun_x = r * Math.cos(ra_sun) * Math.cos(dec_sun);
                sun_y = r * Math.sin(dec_sun);
                sun_z = r * Math.sin(ra_sun) * Math.cos(dec_sun);

                sun_rad = 2 * Math.PI * r * 0.5/360;
                sun_halo_rad = sun_rad * 20;

                var geometry = new THREE.SphereGeometry(sun_rad, 32, 32);
                var halo_geometry = new THREE.CircleGeometry(sun_halo_rad, 32) //SphereGeometry(sun_halo_rad, 32, 32)

                var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                var halo_material = new THREE.MeshBasicMaterial( {color: 0xffff00, transparent: true, opacity: 0.3} );

                var sun = new THREE.Mesh( geometry, material );
                var sun_halo = new THREE.Mesh( halo_geometry, halo_material );

                sun.position.set(sun_x, sun_y, sun_z);
                sun_halo.position.set(sun_x, sun_y, sun_z);
                sun_halo.lookAt(camera.position)

                scene.add(sun);
                scene.add(sun_halo);
                sun.name = "Sun"
                sun_halo.name = "Sun"

            }

            var moon;
            function drawMoon(){
                var lunation = {{ lunation_here }}
                lunation = lunation * Math.PI * 2

                currentJD = new Date().getTime()/86400000 + 2440587.5;

                //moon_pos = astrojs.ephem.moonPos(currentJD);
                //moon_ra = moon_pos["lon"] * Math.PI/180;
                //moon_dec = moon_pos["lat"] * Math.PI/180;
                //moon_dec = (23.4 * Math.PI/180) - moon_dec;

                moon_ra = {{ moon_ra_here }};
                moon_dec = {{ moon_dec_here }};

                moon_rad = 2 * Math.PI * r * 0.5/360;
                moon_halo_rad = sun_rad * 10;

                var geometry = new THREE.SphereGeometry(moon_rad, 32, 32);
                var halo_geometry = new THREE.CircleGeometry(moon_halo_rad, 32)//SphereGeometry(moon_halo_rad, 32, 32);

                var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
                var halo_material = new THREE.MeshBasicMaterial( {color: 0xffffff, transparent: true, opacity: 0.3} );

                moon = new THREE.Mesh( geometry, material );
                var moon_halo = new THREE.Mesh( halo_geometry, halo_material );   

                moon_x = r * Math.cos(moon_ra) * Math.cos(moon_dec);
                moon_y = r * Math.sin(moon_dec);
                moon_z = r * Math.sin(moon_ra) * Math.cos(moon_dec);

                var mult = 1;

                moon.position.set(moon_x*mult, moon_y*mult, moon_z*mult);
                moon_halo.position.set(moon_x*mult, moon_y*mult, moon_z*mult);
                moon_halo.lookAt(camera.position)

                scene.add(moon);
                scene.add(moon_halo);
                moon.name = "Moon"
                moon_halo.name = "Moon"
            }

            var ra = 0;
            var timeoffset = 0;
            var raoffset = 0;
            var raoffset_raw = 0;
            var raoffsetdelta = Math.PI/180;

            function offsetRA(change, reset=false){
                satbox = satellitecheckbox = document.getElementById("drawsatellites");
                
                raoffset += change * Math.PI/180;
                raoffset_raw += change*4
                if (reset==true){
                    raoffset = 0;
                    raoffset_raw = 0;
                }
                timeoffset = raoffset_raw;
                if (satbox.checked){
                    //clearInterval(satelliterefreshID);
                    updateSatellites();
                }

                //get the decimal places right with some float to string and then back to float conversion
                //raoffset_raw = (1 * raoffset_raw).toFixed(3);
                //raoffset_raw = 1 * raoffset_raw;
                //raoffset_raw = raoffset_raw.toString();

                d = document.getElementById("totaloffset");
                d.innerHTML = "<input type='button' class='button' style='--bcolor: #444444; --fsize: 15px;' value='Total Time Offset (min): " + raoffset_raw.toFixed(2) + "'>";
            }

            var ra;
            var mask = '';
            var pointing_az;
            var pointing_alt;
            var antenna = GetURLParameter("antenna");
            //create dummy event to pass to function
            var e = new Object();
            e.keyCode = 13;
            e.which = 13;

            var alt_box = document.getElementById("alt_box");
            var az_box = document.getElementById("az_box");
            var fov_box = document.getElementById("fov_box");
            alt_box.value = GetURLParameter('alt');
            az_box.value = GetURLParameter('az');
            fov_box.value = GetURLParameter('fov');

            var pointing_alt = alt_box.value;
            var pointing_az = az_box.value;
            var fov = fov_box.value;

            dealWithAltAzInput(e);

            function updateAltAz(this_antenna){
                if (this_antenna == "none"){
                    
                }
                else{
                    var alt_box = document.getElementById("alt_box");
                    var az_box = document.getElementById("az_box");
                    var fov_box = document.getElementById("fov_box");
                    altaz = getAntennaData(this_antenna)
                    pointing_alt = altaz[0]
                    pointing_az = altaz[1]
                    alt_box.value = pointing_alt;
                    az_box.value = pointing_az;
                    fov_box.value = 90; //this is the FOV of ATA antennae
                }
            }
            var current_antenna_interval = setInterval(function () {
                updateAltAz(antenna);
                //dealWithAltAzInput(e);
            }, 100);

            function changeAntenna(new_antenna=''){
                new_antenna = document.getElementById("antenna_select").value;
                antenna = new_antenna
                updateAltAz(new_antenna);
                dealWithAltAzInput(e);
                clearInterval(current_antenna_interval);
                if (new_antenna == "none"){
                    var alt_box = document.getElementById("alt_box");
                    var az_box = document.getElementById("az_box");
                    var fov_box = document.getElementById("fov_box");  
                    alt_box.value = 90;
                    az_box.value = 0;
                    fov_box.value = 90;  
                    dealWithAltAzInput(e);
                    current_antenna_interval = ''
                }
                else{
                    current_antenna_interval = setInterval(function () {
                        updateAltAz(new_antenna);
                        dealWithAltAzInput(e);
                    }, 1000);
                }
            }

            function redoAltAz(x, y, z){
                angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];
                for (var i = scene.children.length - 1; i >= 0; i--) {
                    if(scene.children[i].group == "altaz"){
                        if (scene.children[i].name == "textlabel"){
                            //scene.remove(scene.children[i]);
                        }
                        else{
                            scene.children[i].lookAt(x, y, z);
                        }
                    }
                }
            }

            function drawAltAz(x, y, z){

                angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, 5*Math.PI/12];

                var helper = new THREE.PolarGridHelper( r, 16, 1, 64 );
                camera.add( helper );
                helper.group = "altaz"
                helper.position.set(0, 0, -20)
                for (i = 1; i < angles.length; i++){ //skip 0
                    var geometry  = new THREE.CircleGeometry( r*Math.cos(angles[i]), 36)
                    var edges = new THREE.EdgesGeometry(geometry)
                    var circle = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x888888 } ))
                    circle.position.set(0, 0, 0)
                    circle.rotation.set(Math.PI/2, 0, 0)

                    helper.add(circle)
                }
                helper.rotation.set(0, Math.PI/2, Math.PI/2)
                /*var geometry = new THREE.CircleGeometry( ring_rad, 36 )
                var edges = new THREE.EdgesGeometry( geometry );
                var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: color } ) );*/

                //draw the degree labels
                for (i = 0; i < angles.length; i++){
                    a = Math.round(angles[i] * 180 / Math.PI);
                    temprad = r*Math.cos(angles[i]);
                    xyangle = Math.PI/4;
                    x = temprad * Math.sin(xyangle);
                    y = temprad * Math.cos(xyangle)
                    addText(a+String.fromCharCode("0176"), [x, y, -1], "altaz", addtocamera=true);
                }

                //label North
                addText("N", [0.1, 9.5, -1], "altaz", addtocamera=true);

                //label East
                addText("E", [9.5, 0.1, -1], "altaz", addtocamera=true);
            }

            function redoLabels(){
                /*for (var i = scene.children.length - 1; i >= 0; i--) {
                    if(scene.children[i].name == "textlabel"){
                        scene.children[i].quaternion.copy(camera.quaternion);
                    }
                }*/
                for (var i = 0; i < scenetextobjects.length; i++){
                    scenetextobjects[i].quaternion.copy(camera.quaternion);
                    if (scenetextobjects[i].spec == "crosshair"){
                      continue;
                    }
                    scenetextobjects[i].scale.set(1 / camera.zoom, 1 / camera.zoom, 1 / camera.zoom);
                }
            }

            var data = '';
            var satellite_list = [];
            function drawSatellites(){
                data = new XMLHttpRequest();
                data.open("GET", "/static/newtle.txt");
                data.send();
                data.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        data = this.responseText;
                        data = data.split("\n0");
                        //data = data.filter(element => element.includes("STARLINK"));
                    }
                };
            }

            function updateSatellites(){
                /*for (var j = scene.children.length - 1; j >= 0; j--) {
                    if(scene.children[j].group == "Satellite"){
                        scene.remove(scene.children[j]);
                    }
                }*/
 
                for (var i = 0; i < data.length; i+=1){
                    sat = data[i].split("\n")
                    name = sat[0];
                    line1 = sat[1];
                    line2 = sat[2];

                    var satrec = satellite.twoline2satrec(line1, line2);

                    var oldDateObj = new Date();
                    var newDateObj = new Date();
                    newDateObj.setTime(oldDateObj.getTime() + (timeoffset * 60 * 1000));

                    //var timeSinceTleEpochMinutes = Math.floor(new Date().getTime() / 60000);

                    //console.log(timeSinceTleEpochMinutes);

                    //var positionAndVelocity = satellite.sgp4(satrec, timeSinceTleEpochMinutes);
                    var positionAndVelocity = satellite.propagate(satrec, newDateObj);

                    var positionEci = positionAndVelocity.position,
                        velocityEci = positionAndVelocity.velocity;

                    var observerGd = {
                        longitude: satellite.degreesToRadians(longitude),
                        latitude: satellite.degreesToRadians(dec),
                        height: 0.370
                    };

                    var gmst = satellite.gstime(new Date());

                    var positionGd = satellite.eciToGeodetic(positionEci, gmst);

                    var satlongitude = positionGd.longitude,
                        satlatitude  = positionGd.latitude;

                    //if ( Math.abs(satlatitude - dec) < 0.1 && Math.abs(satlongitude - ra) < 0.1){
                    if (satellite_list.includes(name)){
                        var pos = thetaPhiToXYZ(satlongitude, satlatitude)
                        window[name].position.x = pos[0]
                        window[name].position.y = pos[1]
                        window[name].position.z = pos[2]
                    }
                    else{
                        drawObjects([satlongitude], [satlatitude], 0xffffff, [name], "Satellite", true, true);
                    }
                    //}
                    
                }
            }

            function processRaDec(right_asc, decl){
                right_asc = (right_asc[0] * 15) + (right_asc[1] / 4) + (right_asc[2] / 240);
                decl = (decl[0]) + (decl[1] / 60) + (decl[2] / 3600);

                right_asc = + right_asc * Math.PI / 180;
                decl = decl * Math.PI / 180;

                x = r * Math.cos(right_asc) * Math.cos(decl);
                y = r * Math.sin(decl);
                z = r * Math.sin(right_asc) * Math.cos(decl);

                return [x, y, z, right_asc, decl];
            }

            function thetaPhiToXYZ(theta, phi){
                x = r * Math.cos(theta) * Math.cos(phi)
                y = r * Math.sin(phi)
                z = r * Math.sin(theta) * Math.cos(phi)
                return [x, y, z]
            }

            //add significant object labels
            function addObjectLabels(){
                //Crab Pulsar
                right_asc = [5, 34, 31.973];
                decl = [22, 0, 52.06];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("Crab Pulsar", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'Crab Pulsar', group="Important Objects")

                //J0332+5434
                right_asc = [3, 32, 59.4096];
                decl = [54, 34, 43.329];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("J0332+5434", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'J0332+5434', group="Important Objects")

                //SGR 1935+2154
                right_asc = [19, 35, 0];
                decl = [21, 54, 0];

                l = processRaDec(right_asc, decl);
                x = l[0];
                y = l[1];
                z = l[2];
                right_asc = l[3];
                decl = l[4];

                addText("SGR 1935+2154", [x, y + 0.001, z], "Important Objects", false, 0.2);
                drawObjects([right_asc], [decl], 0x00fff8, 'SGR 1935+2154', group="Important Objects")

            }

            var antenna_azel_data;
            //get initial antenna data, populate dropdown menu
            var req = new XMLHttpRequest();        
            req.open("GET", "/antennadata/azel");
            req.send();
            var alt;
            var az;
            req.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    data = this.responseText;
                    data = JSON.parse(data)
                    antenna_azel_data = data;
                    var keys = [];
                    for (var k in data){
                      document.getElementById("antenna_select").innerHTML += "<option value='"+k+"'>"+k+"</option>"
                    }
                }
            };

            //this is to actually get the antenna data for each option
            function getAntennaData(this_antenna){
              var req = new XMLHttpRequest();        
              req.open("GET", "/antennadata/azel");
              req.send();
              var alt;
              var az;
              req.onreadystatechange = function() {
                  if (this.readyState == 4 && this.status == 200) {
                      data = this.responseText;
                      data = JSON.parse(data)
                      antenna_azel_data = data;
                  }
              };
              return [antenna_azel_data[this_antenna]["el"], antenna_azel_data[this_antenna]["az"]]
              /*if (this_antenna == "1a")
                  alt = 90
              if (this_antenna == "1f")
                  alt = 75
              if (this_antenna == "1c")
                  alt = 60
              if (this_antenna == "2a")
                  alt = 45
              if (this_antenna == "2b")
                  alt = 30
              if (this_antenna == "4g")
                  alt = 15
              if (this_antenna == "5c")
                  alt = 0
              var az = Math.round(new Date().getTime() / 1000) + 800
              az = az % 1000
              az = 360 * az/1000*/

              //return ([data[this_antenna]["az"], data[this_antenna]["el"]])
            }

            var camx, camy, camz;
            var backmask = '';
            var pointing_crosshair = '';
            var antenna_fov_line = '';
            var viewrad = r;
            var view_center_x = 0;
            var view_center_y = 0;
            var camyoffset = 0;

            //do the initial ra calculation so interactive mode will start correctly
            ra = calculateSiderealTime(false);
            ra = ra.split(":");

            final_ra = ra[0] * 1;
            final_ra += ra[1] / 60;
            final_ra += ra[2] / 3600;
            final_ra = final_ra * 15;
            final_ra = final_ra * Math.PI / 180;
            ra = final_ra;// - Math.PI/2;
            ra += raoffset;


            function animate() {
              
              for (var i = 0; i < camera.children.length; i++){
                if (camera.children[i].group == "altaz"){
                  if (antenna != "none"){
                    camera.children[i].visible = false
                  }
                  else{
                    gridCheckboxes()
                  }
                }
              }

              pointing_crosshair.visible = false;
              antenna_fov_line.visible = false;
              //camera.remove(antenna_crosshair_text);
              document.getElementById("crosshairtext").innerHTML = ''
              document.getElementById("crosshair_direction_text").innerHTML = ''
              document.getElementById("crosshair_fov_text").innerHTML = ''

              //get the "Actual" altitude for calculation purposes
              act_alt = pointing_alt

              if (antenna != "none"){
                camera.zoom = 75
                pointing_crosshair.visible = true;
                antenna_fov_line.visible = true;
                document.getElementById("crosshairtext").innerHTML = "Az "+String(Math.round(disp_az * 100) /100)+"&#176, El "+String(Math.round(act_alt * 100) / 100)+"&#176"
                document.getElementById("crosshair_direction_text").innerHTML = 'N'
                document.getElementById("crosshair_fov_text").innerHTML = String(Math.round(100 * 180/camera.zoom)/ 200)+"&#176" //divide by 200 here instead of 100 to get the radius rather than the diameter
              }

              //get the "actual" azimuth for calculation purposes
              pointing_az = pointing_az % 360
              disp_az = pointing_az - 90

              if (antenna == "none" && GetURLParameter("controls") == "false"){
                camera.zoom = 1
              }

              viewrad = r * Math.sin(fov * Math.PI / 180);

              //alt_rectangular = r * Math.cos(pointing_alt * Math.PI / 180);

              var antenna_dec = Math.asin( Math.sin(act_alt * Math.PI / 180) * Math.sin(dec) + 
                Math.cos(act_alt * Math.PI / 180) * Math.cos(dec) * Math.cos(disp_az * Math.PI / 180))

              var H = Math.asin( -Math.sin(disp_az * Math.PI / 180) * Math.cos(act_alt * Math.PI / 180) ) / Math.cos(antenna_dec)

              view_center_x = 0//alt_rectangular * Math.cos(pointing_az * Math.PI / 180);
              view_center_y = 0//alt_rectangular * Math.sin(pointing_az * Math.PI / 180);

              /*camera.top = view_center_y + viewrad;
              camera.bottom = view_center_y - viewrad;
              camera.left = view_center_x - viewrad;
              camera.right = view_center_x + viewrad;*/

              camera.updateProjectionMatrix();

              camera.remove(mask);
              mask_geo = new THREE.TorusGeometry(viewrad+5, 5, 2, 100);
              mask_mat = new THREE.MeshBasicMaterial({color:0x000000});
              mask = new THREE.Mesh(mask_geo, mask_mat);
              camera.add(mask);
              mask.position.set(view_center_x, view_center_y, -1);

              ra = calculateSiderealTime(false);
              ra = ra.split(":");

              final_ra = ra[0] * 1;
              final_ra += ra[1] / 60;
              final_ra += ra[2] / 3600;
              final_ra = final_ra * 15;
              final_ra = final_ra * Math.PI / 180;
              ra = final_ra;// - Math.PI/2;
              ra += raoffset;
              //ra = 0;

              antenna_ra = ra - H

              if (pointing_alt < (dec * 180 / Math.PI)){
                antenna_ra += Math.PI
              }

              camx = r * Math.cos(ra) * Math.cos(dec);
              camy = r * Math.sin(dec);
              camz = r * Math.sin(ra) * Math.cos(dec);

               for (var i = 1; i < scene.children.length; i++){
                  if (scene.children[i].group == "equatorial"){
                      continue
                  }
                  x = scene.children[i].position.x
                  y = scene.children[i].position.y
                  z = scene.children[i].position.z
                  d = Math.sqrt((camx-x)*(camx-x) + (camy-y)*(camy-y))
                  d = Math.sqrt(d*d + (camz-z)*(camz-z))
                  if (scene.children[i].hid_override != true || scene.children[i].hid_override == undefined){
                      if (d > 10*Math.sqrt(2)){
                          scene.children[i].visible = false;
                      }
                      else{
                          scene.children[i].visible = true;
                      }
                  }

              }             
              requestAnimationFrame(animate);
              if (GetURLParameter("controls") == "true"){
                  controls.target = new THREE.Vector3(camx/100, camy/100, camz/100);
                  controls.update();
              }

              if (GetURLParameter("controls") == "false"){
                ra = antenna_ra

                camx = r * Math.cos(ra) * Math.cos(antenna_dec);
                camy = r * Math.sin(antenna_dec);
                camz = r * Math.sin(ra) * Math.cos(antenna_dec);
                //camyoffset += 0.01
                //camy += camyoffset
                camera.lookAt(camx, camy, camz);
              }

              renderer.render(scene, camera);

            };

            startScene();
            drawAltAz(0, 0, 0);
            camera.position.set(0, 0, 0);
            camera.zoom = 1;

            var controls = new THREE.TrackballControls(camera, renderer.domElement);
            if (GetURLParameter("controls") == "true"){
              controls.enablePan = true;
              controls.enableDamping = true;
              controls.enableZoom = true;
              controls.keyPanSpeed = 0.2/camera.zoom;
              controls.rotateSpeed = -1/camera.zoom;
              setInterval(function(){
                  controls.keyPanSpeed = 0.2/camera.zoom;
                  controls.rotateSpeed = -1/camera.zoom;
              }, 100)
              controls.dampingFactor = 0.1;
            }
            else{
              controls.enablePan = false;
              controls.enableDamping = false;
              controls.enableZoom = false;              
            }


            animate();
            //setInterval(animate, 1000);

            var satelliterefreshID;
            drawSatellites();
            //redraw sun every half day... hopefully you'll refresh by then...
            setInterval(drawSun(), 43200000);
            drawMoon();
            addObjectLabels();


            renderer.domElement.addEventListener("click", onclick, true);
            var selectedObject;
            var raycaster = new THREE.Raycaster();
            var crosshair = new Object();
            var crosshairinterval;
            raycaster.params.Line.threshold = 0;
            raycaster.params.Sprite.threshold = 0;
            function onclick(event) {
                raycaster.params.Points.threshold = 0.25/camera.zoom// * Math.pow(1.8, camera.zoom)
                raycaster.params.Mesh.threshold = 0.25/camera.zoom
                /*if (antenna != "none"){
                  raycaster.params.Points.threshold = 0.1
                }*/
                var display = false;
                var mouse = new THREE.Vector2();
                var rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ( (event.clientX - rect.left) / window.innerHeight ) * (2) - (1);
                mouse.y = - ( (event.clientY - rect.top) / window.innerHeight ) * (2) + (1);
                raycaster.setFromCamera(mouse, camera);
                var intersects = raycaster.intersectObjects(scene.children, true); //array
                if (intersects.length > 0 && intersects[0].object.group != "altaz" && intersects[0].object.group != "equatorial") {
                    selectedObject = intersects[0]
                    i = 0
                    toprightname = "undefined"
                    display = true;
                    while (selectedObject.object.group == "altaz" || selectedObject.object.group == "equatorial" || selectedObject.object.name == "textlabel" || selectedObject.object.visible == false){
                        i += 1;
                        if (i > intersects.length-1){
                            display = false;
                            break
                        }
                        selectedObject = intersects[i]
                    }

                    if (display != false && selectedObject.object.visible == true){
                        //selectedObject.object.visible = false;
                        //selectedObject.object.hid_override = true;
                        toprightname = selectedObject.object.name;
                        if (selectedObject.object.group == "NVSS Catalog"){ //"calculate" the name for NVSS objects
                          theta = selectedObject.object.theta
                          phi = selectedObject.object.phi


                          theta = theta * 24 / (2 * Math.PI) //get the hours
                          theta_hour = Math.trunc(theta)
                          if (String(theta_hour).length == 1){
                            theta_hour = "0"+theta_hour
                          }

                          theta = theta - theta_hour //get the minutes
                          theta = 60 * theta
                          theta_minute = Math.trunc(theta)
                          if (String(theta_minute).length == 1){
                            theta_minute = "0"+theta_minute
                          }

                          theta = theta - theta_minute //get the seconds
                          theta = 60 * theta
                          theta = Math.trunc(theta)
                          if (String(theta).length == 1){
                            theta = "0"+theta
                          }

                          phi = phi * 180 / (Math.PI) //get the declination degrees
                          phi = phi + 90 //make all phis positive, makes it easier to deal with minutes and seconds
                          phi_degree = Math.trunc(phi)
                          if (String(phi_degree).length == 1){
                            phi_degree = "0"+phi_degree
                          }

                          phi = phi - phi_degree

                          phi_degree = phi_degree - 90
                          if (String(phi_degree).length == 1){
                            phi_degree = "0"+phi_degree
                          }
                          if (String(Math.abs(phi_degree)).length == 1 && phi_degree < 0){ //deal with negative dec
                            phi_degree = "-0"+Math.abs(phi_degree)
                          }
                          if (phi_degree > 0){
                            phi_degree = "+" + phi_degree
                          }

                          phi = 60 * phi // get the declination minutes
                          phi_minute = Math.trunc(phi)
                          phi = phi - phi_minute
                          if (String(phi_minute).length == 1){
                            phi_minute = "0" + phi_minute
                          }

                          phi = phi * 60
                          phi = Math.trunc(phi) //get the declination seconds
                          if (String(phi).length == 1){
                            phi = "0" + phi
                          }

                          toprightname = "NVSS J"+theta_hour+theta_minute+theta+phi_degree+phi_minute+phi
                          toprightname = toprightname + "<br>"
                          toprightname = toprightname + "Flux Density: " + selectedObject.object.lum + " mJy"

                        }
                        document.getElementById("currentobject").innerHTML = toprightname

                        // crosshair size

                        scene.remove(crosshair)
                        x = 0.25/camera.zoom;
                        y = 0.25/camera.zoom;
                        /*if (antenna != "none"){
                          x = camera.top/40
                          y = x
                        }*/

                        // crosshair
                        var material = new THREE.LineBasicMaterial({ color: 0xAAFFAA });

                        upbar = new THREE.Geometry();
                        upbar.vertices.push(new THREE.Vector3(0, y*1.2, 0));
                        upbar.vertices.push(new THREE.Vector3(0, y/3, 0));
                        upbar = new THREE.Line( upbar, material )

                        downbar = new THREE.Geometry();
                        downbar.vertices.push(new THREE.Vector3(0, -y/3, 0))
                        downbar.vertices.push(new THREE.Vector3(0, -y*1.2, 0));
                        downbar = new THREE.Line( downbar, material )

                        leftbar = new THREE.Geometry();
                        leftbar.vertices.push(new THREE.Vector3(x*1.2, 0, 0));
                        leftbar.vertices.push(new THREE.Vector3(x/3, 0, 0));
                        leftbar = new THREE.Line( leftbar, material )

                        rightbar = new THREE.Geometry();
                        rightbar.vertices.push(new THREE.Vector3(-x/3, 0, 0))
                        rightbar.vertices.push(new THREE.Vector3(-x*1.2, 0, 0));
                        rightbar = new THREE.Line( rightbar, material )
                        

                        var curve = new THREE.EllipseCurve(
                            0,  0,            // ax, aY
                            x, y,           // xRadius, yRadius
                            0,  2 * Math.PI,  // aStartAngle, aEndAngle
                            false,            // aClockwise
                            0                 // aRotation
                        );

                        var points = curve.getPoints( 50 );
                        var geometry = new THREE.BufferGeometry().setFromPoints( points );

                        crosshair = new THREE.Line( geometry, material );
                        crosshair.add(upbar)
                        crosshair.add(downbar)
                        crosshair.add(leftbar)
                        crosshair.add(rightbar)

                        clearInterval(crosshairinterval)
                        crosshair.position.copy(selectedObject.object.position)
                        if (selectedObject.object.group == "Satellite"){
                            crosshairinterval = setInterval(function(){crosshair.position.copy(window[toprightname].position)}, 100)
                        }
                        crosshair.hid_override = false;
                        //crosshair.quaternion.copy(camera.quaternion)
                        //keep crosshair pointing to camera
                        crosshair.name = "textlabel"
                        crosshair.spec = "crosshair"
                        scenetextobjects.push(crosshair);
                        scene.add(crosshair)
                    }
                }
            }


            mat = new THREE.LineBasicMaterial( {color: 0xff0000} )
            geo = new THREE.Geometry();
            size = 0.01
            geo.vertices.push(new THREE.Vector3(size, 0, 0));
            geo.vertices.push(new THREE.Vector3(-size, 0, 0));
            geo.vertices.push(new THREE.Vector3(0, 0, 0));
            geo.vertices.push(new THREE.Vector3(0, -size, 0));
            geo.vertices.push(new THREE.Vector3(0, size, 0));
            pointing_crosshair = new THREE.Line(geo, mat);
            pointing_crosshair.position.set(0, 0, -1)
            camera.add(pointing_crosshair)
            pointing_crosshair.visible = false;

            mat = new THREE.LineBasicMaterial( {color: 0xff0000} )
            geo = new THREE.Geometry();
            var outer_rad_antenna = r / 75;
            min = 0.1 * outer_rad_antenna
            max = 0.9 * outer_rad_antenna
            var start = min * Math.cos(Math.PI / 4)
            var end = max * Math.cos(Math.PI / 4)
            geo.vertices.push(new THREE.Vector3(-start, start, 0))
            geo.vertices.push(new THREE.Vector3(-end, end, 0))
            geo.vertices.push(new THREE.Vector3(-end - 0.03 * outer_rad_antenna, end - 0.03*outer_rad_antenna, 0))
            geo.vertices.push(new THREE.Vector3(-end + 0.03 * outer_rad_antenna, end + 0.03*outer_rad_antenna, 0))
            antenna_fov_line = new THREE.Line(geo, mat)
            antenna_fov_line.position.set(0, 0, -1)
            camera.add(antenna_fov_line)
            antenna_fov_line.visible = false;

            drawObjects(atnf_thetas, atnf_phis, 0xff0000, atnf_names, "ATNF Catalog", true);
            //drawObjects(nvss_thetas, nvss_phis, 0x9400d3, nvss_names, "NVSS Catalog", true);
            drawObjects(frb_thetas, frb_phis, 0x00ff00, frb_names, "FRB Catalog", true);
            drawObjects(messier_thetas, messier_phis, 0x00aaff, messier_names, "Messier Catalog", true);
            drawObjects(rrat_thetas, rrat_phis, 0xffff00, rrat_names, "RRAT Catalog", true);
            dealWithCheckboxes();

            tempevent = new Object();
            tempevent.clientX = window.innerWidth / 2
            tempevent.clientY = window.innerHeight / 2
            onclick(tempevent);
            crosshair.hid_override = true;

            setInterval(redoLabels, 10);

            document.getElementById("nonebutton").click();

        </script>
        </gui>
    </body>
</html>